%%
%% $Id: tuning.tex,v 1.2 1999-06-20 23:54:27 tavi Exp $
%%
\chapter{TPIE Performance Tuning}

\section{Choosing a BTE Implementation} % and Setting Parameters}

Choosing the appropriate BTE implementation is both application and
system dependent; and setting up BTE parameters is 
application dependent. We describe here some simple approaches
to determine these; one of the approaches involves using the
\verb|bte_test.c| programs in the test directory.

One criterion that should be carefully considered while setting BTE 
parameters is the \verb|BTE_LOGICAL_BLOCKSIZE_FACTOR|. This parameter
determines the unit of I/O and buffering used by the BTE stream
implementation. In case of \verb|BTE_mmb| or \verb|BTE_ufs|
implementations,  the amount of memory dedicated to a stream is 
either \verb|BTE_LOGICAL_BLOCKSIZE_FACTOR| times the operating system 
blocksize (no prefeteching) or twice  
\verb|BTE_LOGICAL_BLOCKSIZE_FACTOR| times the operating system  blocksize
(in the presence of prefetching). So the value of the
\verb|BTE_LOGICAL_BLOCKSIZE_FACTOR| parameter, together with available
memory, determines the number of BTE streams (and hence AMI streams)
that can be active or ``alive'' at any time. This is an upper bound on
the arity of a multi-way merge or a multi-way distribution operation
that can be undertaken by a TPIE application; which can have a crucial
impact on (say, the number of passes required in external sorting and
hence the) net running time. The size of each buffer and the size of
each I/O in the BTE stream is \verb|BTE_LOGICAL_BLOCKSIZE_FACTOR|
times the operating system  blocksize, so this roughly
corresponds to the amount of data brought in or written out at the
cost of a single disk operation.  The latter observation suggests
that \verb|BTE_LOGICAL_BLOCKSIZE_FACTOR| should be set to a high
value; but a high value for this parameter inhibits the number of 
streams active at a time and hence can result in an increase in the
number of passes required in sorting. In the case of external memory
indexing data structures based on trees, the value of the 
\verb|BTE_LOGICAL_BLOCKSIZE_FACTOR| for any BTE stream (or BTE block
collection, in future TPIE versions) used to implement 
the external memory data structure should be made as close to the size
of the tree node as possible.

In order to decide an appropriate \verb|BTE_LOGICAL_BLOCKSIZE_FACTOR|
or in fact to decide which one of the three BTE implementations 
should be chosen, we also present in the test directory, a C program
called \verb|bte_test.cpp|.
  

This file contains a program that can be used to determine the 
streaming speeds attained by \verb|BTE_stdio|, \verb|BTE_mmb|, and
\verb|BTE_ufs| 
streams on a given system. The performance of these implementations
can vary significantly from system to system; and the information 
that can be attained  can be used to decide which implementation
is appropriate for a given system. 

The C program simulates the buffering and I/O mechanisms/used by each 
one of the BTE stream implementations so that the ``raw'' (only in the 
sense that there is no TPIE layer between
the program and the filesystem) streaming speed of an 
I/O-buffering mechanism combination.

To use the program,  \verb|#define| one of  \verb|MMAP_TEST|,
\verb|READ_WRITE_TEST| or  \verb|STDIO_TEST|
 to be 1 depending on whether you want to test the streaming
speed of  \verb|BTE_mmb|, \verb|BTE_ufs| or  \verb|BTE_stdio|;
\verb|#define|  the other two 
flags to 0. Also \verb|#define| the \verb|BLOCKSIZE_BASE|
 parameter to be equal to the underlying operating system blocksize. 

%NOTE: The \verb|BTE_mmb| stream being simulated here is one that has 
%an \verb|mmap()| based prefetching; this configuration is typically expected
%to be the best possible \verb|mmap()|-based BTE implementation. The \verb|ftruncate()|
%necessary while appending data to an to a file is done once every
%twenty \verb|mmaps()|.  

The program is to be compiled using a C compiler. In order to test the streaming 
performance of  BTE streams of any type T (of size ItemSize), the program 
first writes out some specified number NumStreams of BTE streams containing 
a specified number NumItems of items of size ItemSize. Then, it carries
out a perfect NumStreams-way interleaving of the streams via a simple
merge like process, writing the output to an output stream. During the 
computation, each of the NumStreams streams input to the merge and 
the stream being output by the merge uses either one (when \verb|READ_WRITE_TEST|
or \verb|STDIO_TEST| are set to 1)  or two (when \verb|MMAP_TEST| 
is set to 1) buffers.
In case of \verb|STDIO_TEST|, the buffers are not maintained in the program
but by the stdio library. In the case of \verb|MMAP_TEST| or \verb|READ_WRITE_TEST|,
each buffer is set to be of size \verb|BLOCK_FACTOR| times \verb|BLOCKSIZE_BASE|, and
each I/O operation corresponds to a buffer-sized operation. 

In order to test the streaming performance of a BTE stream with 
\verb|items_in_block| items of size ItemSize in each block (that is, the
block corresponding to the theoretical I/O model), the command line 
sequence is:

\begin{verbatim}
bte_test NumItems ItemSize NumStreams BLOCK_FACTOR items_in_block DataFile 
\end{verbatim}

The output of the program (streaming speed) is appended to the file
DataFile. The streaming speed, alternatively called I/O Bandwidth,
is given in units of MB/s.
\index{block transfer engine|)}

\section{Virtual and Non-virtual Streams}

All the AMI streams in TPIE are instances of a class derived from the base
stream class \verb|AMI_base_stream|. Although this base class has no
functionality in itself, it can provide the minimum set of methods that
need to be implemented by a derived class in order to have the required
stream functionality. This is done by using abstract virtual methods. To
tell TPIE to declare these methods in the base stream class you need to
set \verb|AMI_VIRTUAL_BASE| to 1 (either in the application's
configuration, or during compilation by using the -D flag). Similarly,
\verb|BTE_VIRTUAL_BASE| controls the behavior of the BTE streams.

By default, both BTE and AMI streams use a non-virtual base. By doing this,
the performance of the stream methods is improved dramatically, in many
cases. The biggest gain is obtained from inlining short methods (virtual
methods cannot be inlined). 

We believe this setup provides a good compromise between the need for high
performance one one hand, and clarity, modularity and debugging support on
the other hand.


\section{Inlining Operation Management Object Methods}

The title of this section is self-explanatory. However, failing to inline
the \verb|operate()| method of the operation management classes you create
could be a major source of lackluster performance of your application,
since \verb|operate()| is called once for every element in a stream that is
being scanned. This is, of course, just a suggestion to the compiler, which
can choose to ignore it. In order to maximize the chances to have the
method inlined, keep it short and simple. A way to do this is to wrap
complex pieces of code that are called less often in separate functions.

\section{Other factors afecting performance}

This is an eclectic list of performance-afecting parameters, not all of
which are TPIE specific.
\begin{itemize}
\item[g++ optimization] We recommend using the \verb|-O2| level of
optimization of g++ in order to obtain the best overall
performance. Although higher speeds could be obtained using \verb|-O3|,
this optimization leads to increased size of the program, potentially
hurting performance. 
\item[memory size] To insure that no disk swapping is done, the size of
main memory used by TPIE should be set to a realistic value, which is
usually much smaller than the size of the memory installed in the computer
(due to operating system resources and daemons).
\end{itemize}

%\section{Using Multiple Physical Devices}
