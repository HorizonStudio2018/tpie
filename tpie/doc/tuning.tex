%%
%% $Id: tuning.tex,v 1.1 1999-03-04 00:33:35 tavi Exp $
%%
\chapter{TPIE Performance Tuning}

\section{Choosing a BTE Implementation} % and Setting Parameters}

Choosing the appropriate BTE implementation is more often than
not system dependent; and setting up BTE parameters is 
application dependent. We describe here some simple approaches
to determine these; one of the approaches involves using the
\verb|bte_test.c| programs in the test directory.

One criterion that should be carefully considered while setting BTE 
parameters is the \verb|BTE_LOGICAL_BLOCKSIZE_FACTOR|. This parameter
determines the unit of I/O and buffering used by the BTE stream
implementation. In case of \verb|BTE_mmb| or \verb|BTE_ufs|
implementations,  the amount of memory dedicated to a stream is 
either \verb|BTE_LOGICAL_BLOCKSIZE_FACTOR| times the operating system 
blocksize (no prefeteching) or twice  
\verb|BTE_LOGICAL_BLOCKSIZE_FACTOR| times the operating system  blocksize
(in the presence of prefetching). So the value of the
\verb|BTE_LOGICAL_BLOCKSIZE_FACTOR| parameter, together with available
memory, determines the number of BTE streams (and hence AMI streams)
that can be active or ``alive'' at any time. This is an upper bound on
the arity of a multi-way merge or a multi-way distribution operation
that can be undertaken by a TPIE application; which can have a crucial
impact on (say, the number of passes required in external sorting and
hence the) net running time. The size of each buffer and the size of
each I/O in the BTE stream is \verb|BTE_LOGICAL_BLOCKSIZE_FACTOR|
times the operating system  blocksize, so this (very) roughly
corresponds to the amount of data brought in or written out at the
cost of a single disk operation.  The latter observation suggests
that \verb|BTE_LOGICAL_BLOCKSIZE_FACTOR| should be set to a high
value; but a high value for this parameter inhibits the number of 
streams active at a time and hence can result in an increase in the
number of passes required in sorting. In the case of external memory
indexing data structures based on trees, the value of the 
\verb|BTE_LOGICAL_BLOCKSIZE_FACTOR| for any BTE stream (or BTE block
collection, in future TPIE versions) like structure used to implement 
the external memory data structure should be made as close to the size
of the tree node as possible.

In order to decide an appropriate \verb|BTE_LOGICAL_BLOCKSIZE_FACTOR|
or in fact to decide which one of the three BTE implementations 
should be chosen, we also present in the test directory, a C program
called \verb|bte_test.cpp|.
  

This file contains a program that can be used to determine the 
streaming speeds attained by \verb|BTE_stdio|, \verb|BTE_mmb|, and
\verb|BTE_ufs| 
streams on a given system. The performance of these implementations
can vary significantly from system to system; and the information 
that can be attained  can be used to decide which implementation
is appropriate for a given system. 

The C program simulates the buffering and I/O mechanisms/used by each 
one of the BTE stream implementations so that the ``raw'' (only in the 
sense that there is no TPIE layer between
the program and the filesystem) streaming speed of an 
I/O-buffering mechanism combination.

To use the program,  \verb|#define| one of  \verb|MMAP_TEST|,
\verb|READ_WRITE_TEST| or  \verb|STDIO_TEST|
 to be 1 depending on whether you want to test the streaming
speed of  \verb|BTE_mmb|, \verb|BTE_ufs| or  \verb|BTE_stdio|;
\verb|#define|  the other two 
flags to 0. Also \verb|#define| the \verb|BLOCKSIZE_BASE|
 parameter to be equal to the underlying operating system blocksize. 

NOTE: The \verb|BTE_mmb| stream being simulated here is one that has 
an \verb|mmap()| based prefetching; this configuration is typically expected
to be the best possible \verb|mmap()|-based BTE implementation. The \verb|ftruncate()|
necessary while appending data to an to a file is done once every
twenty \verb|mmaps()|.  

The program is to be compiled using a C compiler. In order to test the streaming 
performance of  BTE streams of any type T (of size ItemSize), the program 
first writes out some specified number NumStreams of BTE streams containing 
a specified number NumItems of items of size ItemSize. Then, it carries
out a perfect NumStreams-way interleaving of the streams via a simple
merge like process, writing the output to an output stream. During the 
computation, each of the NumStreams streams input to the merge and 
the stream being output by the merge uses either one (when \verb|READ_WRITE_TEST|
or \verb|STDIO_TEST| are set to 1)  or two (when \verb|MMAP_TEST| 
is set to 1) buffers.
In case of \verb|STDIO_TEST|, the buffers are not maintained in the program
but by the stdio library. In the case of \verb|MMAP_TEST| or \verb|READ_WRITE_TEST|,
each buffer is set to be of size \verb|BLOCK_FACTOR| times \verb|BLOCKSIZE_BASE|, and
each I/O operation corresponds to a buffer-sized operation. 

In order to test the streaming performance of a BTE stream with 
\verb|items_in_block| items of size ItemSize in each block (that is, the
block corresponding to the theoretical I/O model), the command line 
sequence is:

\begin{verbatim}
bte_test NumItems ItemSize NumStreams BLOCK_FACTOR items_in_block DataFile 
\end{verbatim}

The output of the program (streaming speed) is appended to the file
DataFile. The streaming speed, alternatively called I/O Bandwidth,
is given in units of MB/s.
\index{block transfer engine|)}

\section{Virtual and Non-virtual Streams}


\section{Inlining Operation Management Object Member Functions}


\section{Using Multiple Physical Devices}
