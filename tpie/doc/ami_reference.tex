%%
%% $Id: ami_reference.tex,v 1.5 1999-10-13 21:01:36 hutchins Exp $
%%
\chapter{TPIE Programmers' Reference}
\label{cha:reference}

\comment{LA: Statistics somewhere!}

\comment{LA: pqueue, internal sort, ect somewhere?}

TPIE has three main components, the Access Method Interface
(AMI), a Block Transfer Engine (BTE), and a Memory Manager.
A BTE handles disk block transfers and the MM performs low
level memory management. The AMI works on top of the Memory
Manager and one or more BTEs to provide a uniform interface
for application programs. Applications that use this
interface are portable across hardware platforms, since they
never have to deal with the underlying details of how I/O is
performed on a particular machine. This chapter contains a
description of the AMI and Memory Manager entry points that
an application programmer might normally use. Typically, an
application programmer will not request services from a BTE
directly. Refer to Chapter~\ref{cha:implementation} for a
description of BTEs and for TPIE implementation details.


\section{TPIE Memory Management}
\label{sec:mm-ref}

The Memory Manager components of TPIE provide services related to
the management of internal memory:
\begin{itemize}
\item allocation and deallocation of (internal)
memory as requested by the \verb|new| and \verb|delete| operators,
\item accounting of memory usage (when required),
\item enforcing of the user-specified internal memory usage
limit (when required),
\item logging of memory allocation requests (when required).
\end{itemize}

%The TPIE memory manager \verb|MM_manager|, is built from the source
%files \verb|mm_register.cpp|, \verb|mm_base.cpp|, \verb|mm_register.h|, and
%\verb|mm\_base.h|. 
The TPIE memory manager \verb|MM_manager| traps memory
allocation and deallocation requests in order to monitor
and enforce memory usage limits. It provides a number of
user-callable functions and services.

\begin{itemize}
\item Replacement of the default C++ \verb|new| operator
\begin{verbatim}
void * operator new (size_t) sz;
\end{verbatim}
This function returns a pointer to a memory block of sixe
\verb|sz| bytes, where \verb|sz| is initialized by the
compiler, and contains the size of the object
for which memory is required. The calling program syntax is
exactly the same as when invoking the default \verb|new|
operator of the C++ library, i.e. 

\begin{verbatim}
anObject *p;
p = new anObject; 
\end{verbatim}

\item Replacement of the default C++ \verb|delete| and
\verb|delete []| operators
\begin{verbatim}
void operator delete    (void *ptr);
void operator delete [] (void *ptr);
\end{verbatim}

These functions deallocate the memory pointed to by
\verb|ptr|. The calling program syntax and usage is exactly
the same as when invoking the default \verb|delete| and
\verb|delete []| operators of the C++ runtime library.

\end{itemize}

Although provisions exist for alternative memory managers,
TPIE currently provides only one. TPIE's memory manager is the object
\verb|MM_manager|, which has global scope.  The following
public methods of object \verb|MM_manager| are provided:

\begin{itemize}
\item Setting an application's memory limit:
\begin{verbatim}
MM_err set_memory_limit (size_t size);
\end{verbatim}

The memory limit is set to \verb|size| bytes. If the
specified mamory limit is greater than or equal to the
amount of memory already allocated, \verb|set_memory_limit|
returns \verb|MM_ERROR_NO_ERROR|, otherwise
\verb|MM_ERROR_EXCESSIVE_ALLOCATION|. By default, successive
calls to operator \verb|new| will cause the program to abort
if the resulting memory usage would exceed \verb|size|
bytes. This behaviour can be controlled explicitly by the
use of methods \verb|enforce_memory_limit|,
\verb|warn_memory_limit| and \verb|ignore_memory_limit|.
See below for details.

\item Setting enforcement behaviour:
\begin{verbatim}
MM_err enforce_memory_limit();
MM_err ignore_memory_limit ();
MM_err warn_memory_limit   ();
\end{verbatim}

Methods \verb|enforce_memory_limit|,
\verb|ignore_memory_limit| and \verb|warn_memory_limit| are
used to specify the behaviour desired in the event that the
user-specified memory limit is exceeded. These methods cause
TPIE to abort, continue without warning, or continue after a
warning, respectively.

\item Query memory parameters

\begin{verbatim}
long memory_available();
long memory_used();
long memory_limit();
\end{verbatim}

Method \verb|memory_available()| returns the number of bytes
of memory which can be allocated before the user-specified
limit is reached. \verb|memory_used| returns the number of
bytes of memory currently allocated. \verb|memory_limit|
returns the memory limit as set by the last call to method
\verb|set_memory_limit|.

Application programs which wish to limit their main memory
usage can check via \verb|memory_available| whether a
contemplated memory allocation request would exceed their
self-imposed threshold.

\item Query space overhead

\begin{verbatim}
int space_overhead();
\end{verbatim}

TPIE imposes a small space overhead on each memory
allocation request received by operator \verb|new|. This involves
increasing each allocation request by a fixed number of
bytes. The precise size of this increase is machine
dependent, but typically 8 bytes. Method \verb|space_overhead|
returns the size of this increase.
\end{itemize}

\subsection{Using the Memory Manager: An Example}

The following (toy) program creates new elements of a linked
list until its specified memory limit has been reached.

\begin{verbatim}
// This program illustrates the use of the main public 
// entry points in the TPIE memory manager object "MM_manager".
// It creates nodes in a linked list and stops when a predefined memory 
// limit would be exceeded if it continued.

#include "app_config.h"
#include <ami.h>
#define  MY_MEMORY_LIMIT 4*1024*1024;

int    overhead, nodeCount;
size_t mem_limit = MY_MEMORY_LIMIT;
class  myNode 
       { public:
            int i[1020/4];
            myNode *next;
       };
myNode *firstNode, *currentNode, *previousNode;

void 
main (int argc, char *argv[]){
 
   overhead = MM_manager.space_overhead();
   nodeCount = 0;
   MM_manager.set_memory_limit(mem_limit);
   currentNode = firstNode = 0;

   while ((sizeof(myNode)+overhead)<= MM_manager.memory_available()) { 
      currentNode = new myNode;
      if (firstNode == 0) 
         firstNode = currentNode;
      else
        (*previousNode).next = currentNode;
      (*currentNode).next = 0;
      previousNode = currentNode;
      nodeCount++;
   };
   cout << nodeCount << " list nodes of size " << (int) sizeof(myNode); 
   cout << " were allocated within my memory limit of ";
   cout << (size_t) mem_limit << " bytes \n";
};
\end{verbatim}

Under PC Solaris, this program gives the following output:
\begin{verbatim}
4064 list nodes of size 1024 were allocated within my memory limit of 4194304 bytes
\end{verbatim}
\comment{LA: Index!}
\section{AMI Streams}
\label{sec:ami_stream-ref}

\tobeextended
\comment{LA: This whole section needs an overhaul! (e.g. check that
everything is included and correct).}
An AMI stream\index{streams!AMI} is
an abstraction of an ordered collection of objects of a
particular class which is stored in secondary memory.  In some
applications, the elements of a stream might be integers.
In others, they might be objects of an arbitrarily complex, user-defined
class.  A stream of objects of class \verb|foo| called
\verb|foo_stream| is created in a TPIE program as follows:

\begin{verbatim}
AMI_STREAM<foo> foo_stream;
\end{verbatim}

{\em The public member functions of the \verb|AMI_STREAM|
   class are defined in the file ``ami\_single.h''. Some
   important related enumerated types that the user will be
   concerned with are defined in ``ami\_base.h''.
   \verb|AMI_STREAM| is a macro that resolves to a class
   template declared to match the underlying semantics of
   the target I/O architecture by using an appropriate AMI
   implementation (see section~\ref{sec:ref-ami}), BTE
   implementation\index{block transfer engine} (see
   Section~\ref{sec:ref-bte}) and MM (see
   Section~\ref{sec:ref-mm}) implementation. In the current
   version of TPIE an \verb|AMI_STREAM| is stored in a
   standard UNIX file on a single disk.}

In version \version of TPIE,  the \verb|AMI_STREAM| class has the
following public member functions:
\comment{LA: Change when parallel disks are introduced}

\comment{LA: Probably put some general discussion of stream types
(read/write/append) and persistence here. Same comment about substreams and
{\em current\_item}.}

\comment{LA: Remove bullets?}
\begin{itemize}
\item{Constructors (and Destructor)}

There are four constructor polymorphs.

\begin{verbatim}
     AMI_STREAM();
     AMI_STREAM(const char *path_name);
     AMI_STREAM(const char *path_name, AMI_stream_type st);
     AMI_STREAM(BTE_STREAM<T> &bs);
\end{verbatim}


 If
no arguments are given to the constructor, a new stream 
%of type \verb|AMI_READ_WRITE_STREAM| 
is constructed on a file with a randomly generated name. If
\verb|path-name| is given and the file does not already
exist, a new stream is constructed on a newly created file
with the specified file name. If the file already exists, it
is checked if it contains an \verb|AMI_STREAM|, and if so,
the new stream is constructed on this file. 

An \verb|AMI_stream| can have one of four different types
\verb|AMI_READ_STREAM|, \verb|AMI_WRITE_STREAM|,
\verb|AMI_APPEND_STREAM|, or \verb|AMI_READ_WRITE_STREAM|,
which define what operations will be permitted on the
stream.\comment{LA: Check that this works ok in the code -
   also check that r\_only is correct. Another problem is
   that AMI and BTE WRITE\_STREAM flags have different
   semantics - needs to be cleaned up} If \verb|st| is not
specified, the stream type defaults to
\verb|AMI_READ_WRITE_STREAM|. The \verb|AMI_APPEND_STREAM|
type is like \verb|AMI_WRITE_STREAM| type\comment{LA: It
   this true?} except that if the stream is constructed on a
file containing an existing stream, objects written to the
stream will be appended at the end of the stream.

The last constructor, which will not normally be used by a
TPIE application programmer\comment{LA: Why do we have it
   then?}, constructs a stream from an existing
\verb|BTE_STREAM| (see Section~\ref{sec:ref-bte}). The
stream gets the same type as the \verb|BTE_STREAM|.


\item{Substreams}

It is possible to construct an AMI stream that is composed
of a portion of another AMI stream. A substream $B$ of a
stream $A$ is defined as a contiguous range of objects from
the ordered collection of objects that make up the stream
$A$.  If desired, one can construct substreams of substreams
of substreams {\em ad infinitum}.

In order to create a substream, one has to use a pseudo-constructor called
\verb|new_substream()|, which is declared as follows:\comment{LA: Why is it
called AMI\_stream\_single? Change!}
\begin{verbatim}
AMI_err AMI_stream_single<T>::new_substream(AMI_stream_type st,
                                            off_t sub_begin,
                                            off_t sub_end,
                                            AMI_base_stream<T> **sub_stream)
\end{verbatim}
\verb|st| specifies the type of the stream. The offsets \verb|sub_begin| and
\verb|sub_end| of type \verb|off_t| define at which object
in the original stream $A$
the new substream $B$ will begin and end. Upon completion, \verb|*sub_stream| points to the newly allocated and created substream.

The\comment{LA: I don't understand this paragraph} reason we do not use a
real constructor is to get around the fact that constructors can not be
virtual. Because \verb|new_substream()| is not a constructor, but rather a
function each particular implementation of which calls an appropriate
constructor, it can be a pure virtual function in the stream base class,
which forces it to be defined for all actual stream implementations. This
is discussed in more detail in Sections~\ref{sec:ref-bte}
and~\ref{sec:ref-ami},\comment{LA: Is it?} which discuss the implementation
of the AMI and BTE in more detail.

\item{Reading and Writing}

\begin{verbatim}
    AMI_err read_item(T **elt);
    AMI_err write_item(const T &elt);
\end{verbatim}

\verb|AMI_STREAM|s have a notion of \verb|current_item| in the stream of
objects. The \verb|read_item(T **elt)| function returns with \verb|*elt|
pointing to the current object of the \verb|AMI_STREAM<T>| and the
\verb|write_item(T elt)| function returns after setting the current object
of \verb|AMI_STREAM<T>| to the value \verb|elt|. The two functions also
increment the \verb|current_item|.

Since it can be useful to read or write many objects at a time from or to
an \verb|AMI_STREAM|, TPIE provides two functions to do so.

\begin{verbatim}
    read_array(T *mm_space, off_t *len)
    write_array(const T *mm_space, off_t len)
\end{verbatim}

\verb|read_array| read \verb|*len| objects from the \verb|current_item| into
the array \verb|mm_space|. Similarly, \verb|write_arrar| writes an
array.\comment{LA: Why is there a difference in the passing of len?}

\item{Seeking}

\verb|current_item| can be explicitly changed with the \verb|seek| function.
\begin{verbatim}
    AMI_err seek(off_t offset);
\end{verbatim}

\item{Truncating}

Apart from by using \verb|write_item()| a stream can be extended
(truncated) using the function \verb|truncate()|.

\begin{verbatim}
    AMI_err truncate(off_t offset);
\end{verbatim}
The function extends the stream to the specified number of
objects. \verb|current_item| will be moved to the end of the stream.

\item{Getting main memory usage}

\begin{verbatim}
    AMI_err main_memory_usage(size_t *usage,
                              MM_stream_usage usage_type);
\end{verbatim}

This function is used for obtaining the amount of main memory used by a
stream (in bytes). \verb|usage_type| is one of
\verb|MM_STREAM_USAGE_CURRENT|, \verb|MM_STREAM_USAGE_MAXIMUM|, and
\verb|MM_STREAM_USAGE_SUBSTREAM| which gives the current use, the maximal
amount that will ever be used, and the additional amount which will be used
by each substream created, respectively.\comment{LA: There seems to be two
more types defined in mm.base.h - what are they?}

\item{Naming}

\begin{verbatim}
    AMI_err name(char **stream_name);
\end{verbatim}

Returns the name of the UNIX file storing the stream.  The
name will be stored in newly allocated space.

\item{Length}

\begin{verbatim}
    off_t stream_len(void);
\end{verbatim}

Returns the current number of objects in the stream.

\item{Available Streams}
\begin{verbatim}
    int available_streams(void);    
\end{verbatim}

Typically, there is an operating system limit on the number
of open files. This translates into a limit on the number of
TPIE streams. Method \verb|available_streams| returns the
number of streams which can still be constructed.

\item{Set persistence}

\begin{verbatim}
    void persist(persistence);
\end{verbatim}

Sets the persistence of the stream to one of the following:
\begin{itemize}
\item \verb|PERSIST_DELETE|: Delete the stream from the disk when it is
  destructed.
\item \verb|PERSIST_PERSISTENT|: Do not delete the stream from the disk when
  it is destructed.
%\item \verb|PERSIST_READ_ONCE:| Delete each block of data from the disk as
%  it is read.
\end{itemize}

By default, all streams are deleted at destruction time
(\verb|PERSIST_DELETE|).\comment{LA: There seems to be an unused
PERSIST\_READ\_ONCE flag as well! (from darren's delete-block
stuff). Remove?!}
\end{itemize}



\section{AMI Entry Points}

\index{AMI entry point}\index{entry point!AMI|see{AMI entry point}}

\subsection{Scanning}
\label{sec:ref-ami-scan}

\index{scanning|(}

The simplest polymorph of \verb|AMI_scan()| is
\begin{verbatim}
    AMI_err AMI_scan(ST *smo, AMI_STREAM<T> *outstream);
\end{verbatim}
which generates an output stream of objects of type \verb|T|.
\verb|smo| is a pointer to a scan management object of used defined
class \verb|ST|.  \verb|ST| should provide member functions {\tt
  AMI\_err initialize(void)} and {\tt AMI\_err operate(T *out1,
  AMI\_SCAN\_FLAG *sf)}.

Scanning can also read and process an input stream of objects of type
\verb|T|.  The polymorph that does this looks as follows
\begin{verbatim}
    AMI_err AMI_scan(AMI_STREAM<T> *instream, ST *smo);
\end{verbatim}
Again, \verb|smo| is a pointer to a scan management object of used
defined class \verb|ST|.  \verb|ST| should provide member functions
{\tt AMI\_err initialize(void)} and {\tt AMI\_err operate(const T
  \&in1, AMI\_SCAN\_FLAG *sf)}.

\verb|AMI_scan()| may also read multiple input streams, each
potentially of a different type, and write multiple output streams,
each potentially of a different type.  This is done using the polymorph
\index{scanning!multi-type}
\begin{verbatim}
    AMI_err AMI_scan(AMI_STREAM<T1> *instream1, 
                     AMI_STREAM<T2> *instream2, ..., 
                     ST *smo, 
                     AMI_STREAM<U1> *os1, 
                     AMI_STREAM<U1> *os2, ...);
\end{verbatim}
The scan management object class \verb|ST| should have an operate
method taking the appropriate number and type of operands.  For
example, {\tt AMI\_err operate(const T1 \&in1, const T2 \&in2, ...,
  AMI\_SCAN\_FLAG *sfin, U1 *out1, U2 *out2, ..., AMI\_SCAN\_FLAG
  *sfout)}.  In the current implementation of TPIE there can be
between zero and four inputs and zero and four outputs.


\subsubsection{Scan Management Objects}  
\index{operation management objects!scan|(}

A scan management object class must provide two member functions for
\verb|AMI_scan()| to call.\comment{LA: Something about subclass of
AMI\_scan\_object (also in previous text)?} The first is
\begin{verbatim}
    AMI_err initialize(void);
\end{verbatim}
\verb|initialize()| initializes the object to prepare it for a scan.  This
member function is called once by each call to \verb|AMI_scan()| in order
to initialize the scan management object before any data processing takes
place. This function should return \verb|AMI_ERROR_NO_ERROR| if
successful, or an appropriate error otherwise. See
Section~\ref{sec:ami-errors} for a list of error codes.

Most of the work done is a scan is typically done in the scan management
objects member function
\begin{verbatim}
    AMI_err operate(const T1 &in1, ...,  AMI_SCAN_FLAG *sfin,
                    U1 *out1, ..., AMI_SCAN_FLAG *sfout);
\end{verbatim}

Either one or more input objects or one or more output parameters must
be specified.  These must correspond in number and type to the streams
passed to the polymorph of \verb|AMI_scan()| with which this scan
management object is to be used.

If there are inputs, \verb|sfin| points to an array of flags, one for each
input parameter.  Flags that are set (non-zero) indicate that the
corresponding input parameters are valid.  If the input flags are left
untouched, it is assumed that the input parameters were processed.  If one
or more are cleared (set to zero) then the it is assumed that the
corresponding inputs were not processed and should be presented again on
the next call to \verb|operate()|.  This permits out of step
scanning\index{scanning!out of step}, as illustrated in
Section~\ref{sec:out-of-step}.

The output parameters are used to store objects to be written to the output
streams. The output flags must be set by \verb|operate()| to indicate which
outputs are valid and should be written to the output streams. 

The return value of \verb|operate()| will normally be either
\verb|AMI_SCAN_CONTINUE|, which indicates that the function should be
called again with any taken input parameters replaced by the next objects
from the streams they came from, of \verb|AMI_SCAN_DONE|, which indicates
that the scan is complete and no more input needs to be processed.  Note
that \verb|operate()| may continue to return \verb|AMI_SCAN_CONTINUE| even
when the input flags indicate that their is no more input to be processed.
This is useful if the scan management object maintains some internal state
that must be written out after all input has been processed.

\comment{LA: Something about special built-in scan management objects, e.g,
ASCII input/output}

%There are numerous examples of scan management objects in
%Section~\ref{sec:scanning} as well as in the test applications that
%appear in the TPIE distribution.


\index{operation management objects!scan|)}
\index{scanning|)}


\subsection{Merging}
\label{sec:ref-ami-merge}
\index{merging|(}

To merge a number of streams in a single pass\comment{LA: Understandable?},
TPIE provides the entry point.

\begin{verbatim}
AMI_err AMI_merge(AMI_STREAM<T> **instreams, arity_t arity,
                  AMI_STREAM<T> *outstream, M *m_obj);
\end{verbatim}

\verb|instreams| is an array of pointers to the input streams, all of which
are streams of objects of type \verb|T|. \verb|arity| is the number of
input streams. \verb|outstream| is the output stream.  Finally,
\verb|m_obj| points to a merge management object which will control the
merge. Merge management objects are described below. If the number of
streams is large enough that all streams cannot be properly buffered in the
available main memory\comment{LA: Do the reader know what we are talking
about here?}, then this function will fail, returning
\verb|AMI_ERR_INSUFFICIENT_MAIN_MEMORY|.

Most programs are unlikely to need to call \verb|AMI_merge()|
directly.\comment{LA: Really?} More commonly, programs will wish to
partition a stream into substreams small enough to fit in main memory,
operate on each in main memory, and then merge them together, possibly in
several passes if low memory conditions dictate. TPIE provides the entry
point to do this, which is
\begin{verbatim}
AMI_err AMI_partition_and_merge(AMI_STREAM<T> *instream,
                                AMI_STREAM<T> *outstream, M *m_obj);
\end{verbatim}
This entry point takes care of all the details of determining how much
main memory is available, how big the initial substreams can be, how
many streams can be merged at a time, and how many levels of merging
must take place.

\subsubsection{Merge Management Objects}  
\index{operation management objects!merge|(} A merge management object
must provide \verb|initialize()| and \verb|operate()| member
functions, whose functions are analogous to their namesakes for scan
management objects.  They should be declared as
\begin{verbatim}
    AMI_err initialize(arity_t arity, const T * const *in,
                       AMI_merge_flag *taken_flags,
                       int &taken_index);
\end{verbatim}
and
\begin{verbatim}
    AMI_err operate(const T * const *in, AMI_merge_flag *taken_flags,
                    int &taken_index, T *out);
\end{verbatim}
The arguments to \verb|initialize()| are \verb|arity|, the number of
input streams in the merge, \verb|in| a pointer to an array of
pointers to input objects, each of which is the first objects appearing
in one of the input streams,  \verb|taken_flags| an array of flags
indicating which of the inputs are present (i.e. which of the input
streams is not empty), and a pointer to an output object.

The typical behavior of an \verb|initialize()| member function for a
merge management object is to place all the input objects into a data
structure and then return \verb|AMI_MERGE_READ_MULTIPLE| to indicate
that it took all the inputs which were indicated to be valid by
\verb|taken_flags|.  \verb|initialize| need not process all inputs; it
can turn off any flags in \verb|taken_flags| corresponding to inputs
that should be presented to \verb|operate()|.  Alternatively, it can
set \verb|taken_index| to the index of a single input it processed and
return \verb|AMI_MERGE_CONTINUE|.

The \verb|operate()| member function for a merge management object is
called repeatedly to process input objects.  Typically, this member
function will choose one input object to process, and set
\verb|taken_index| to the index of the pointer to that object in the input
array.  This object is then typically added to a dynamic data structure
maintained by the merge management object.  If output is generated, for
example by removing an object from the dynamic data structure,
\verb|operate()| should return \verb|AMI_MERGE_OUTPUT|, otherwise, it
returns either \verb|AMI_MERGE_CONTINUE| to indicate that more input should
be presented, or \verb|AMI_MERGE_DONE| to indicate that the merge has
completed.

Alternatively, \verb|operate()| can clear the elements of
\verb|taken_flags| that correspond to inputs it does not currently wish to
process, and then return \verb|AMI_MERGE_READ_MULTIPLE|.  This is generally
undesirable because, if only one input is taken, it is far slower than
using \verb|taken_index| to indicate which input was taken.  The merge
management object must clear all other flags, and then TPIE must test all
the flags to see which inputs were or were not processed.

Any merge management object that is used with the entry point
\verb|AMI_partition_and_merge()| needs to provide three additional a member
function. One function is used to operate on substreams of data that are
small enough to fit into main memory. This member function is
\begin{verbatim}
    AMI_err main_mem_operate(T* mm_stream, size_t len);
\end{verbatim}
\verb|mm_stream| is a pointer to an array of objects that have been read
into main memory. \verb|len| is the number of objects in the array. The two
other member functions are functions for communicating to TPIE how much
main memory the merge management object use. Merge management objects are
allowed to maintain data structures whose size is linear in the number of
input streams being processed.
\begin{verbatim}
    size_t space_usage_overhead(void);
    size_t space_usage_per_stream(void);
\end{verbatim}
The first function should return an upper bound on the amount of main
memory\comment{LA: In bytes?} the object will allocate in addition to the
portion that is linear in the number of streams. The second should return
the amount of additional main memory needed per input stream.

%There are examples of merge management objects in
%Section~\ref{sec:merging} as well as in the test applications that
%appear in the TPIE distribution.

\index{operation management objects!merge|)}
\index{merging|)}


\subsubsection{AMI merging without Merge Management Objects}
\label{sec:ref-miami-merge}
\comment{LA: merging without merge management object in index}

By using appropriate \verb|operate()| and \verb|main_mem_operate()|
functions, \verb|AMI_merge()| can be used to conveniently program
operations other than standard comparison based merging. TPIE also provide
three other \verb|AMI_merge()| polymorphs for the special (normal) case of
merging (partly for efficiency reasons):

\begin{verbatim}
  AMI_err AMI_merge(AMI_STREAM<T> **instreams,
                    arity_t arity, 
                    AMI_STREAM<T> *outstream);
  AMI_err AMI_merge(AMI_STREAM<T> **instreams,
                    arity_t arity,
                    AMI_STREAM<T> * outstream,
                    int (*cmp)(CONST T&, CONST T&));
  AMI_err AMI_merge(AMI_STREAM<T> **instreams,
                    arity_t arity,
                    AMI_STREAM<T> *outstream,
                    int keyoffset, KEY dummy);
\end{verbatim}

\comment{LA: We need to add comparator class polymorph}

The first polymorph works on streams of objects for which the operator
\verb|<| is defined.

The second polymorph uses an explicit user defined function to compare
objects. The function takes two objects of type T and returns a negative,
zero or positive number depending on whether or not the first object is
less than, equal to or greater than the second object in the desired
merging order.

The third polymorphs assumes that the objects (of type T) in the streams
being merged have a field (of type \verb|KEY|) with well-defined (possibly
by means of overloading) \verb|<| operator, and that the ordering of the
object is to be based on the total order of this field. \verb|keyoffset| is
the offset within an object of type T of this key field, and \verb|dummy| is
a (any) variable of type \verb|KEY|.\comment{LA: Something about this being
for C++ reasons?}

All three polymorphs return \verb|AMI_ERR_INSUFFICIENT_MAIN_MEMORY| if not
enough main memory is available to perform the merge.


%The motivation for such a function is to exploit situations
%in which the KEY field is often much smaller than the T type object: For
%instance, if T is a rectangle, each object may be of size approximately 40
%bytes, whereas if one is interested in sorting along the X co-ordinate, the
%KEY may be of size 4 or 8 bytes.  If such information is known to the
%programmer, the above entry point can exploit it by using
%appropriately-suited simple internal memory merging techniques: Often, the
%small size of the KEY field can improve the running time of the operation.

%We also provide three entry points analogous to the
%\verb|AMI_partition_and_merge()| function that do not require merge
%management objects and that use the \verb|MIAMI_single_merge_*()| routines
%the way \verb|AMI_partition_and_merge()| uses the
%\verb|AMI_single_merge()|: Each analogue entry point corresponds to one of
%the above three \verb|MIAMI_single_merge_*()| entry points.
%
%
%The first function, based on \verb|MIAMI_single_merge_stream()|,
%\begin{verbatim}
%template<class T>
%AMI_err AMI_partition_and_merge_stream(AMI_STREAM<T> *instream,
%                                       AMI_STREAM<T> *outstream)
%\end{verbatim}
%provides the exact same functionality as the
%\verb|AMI_partition_and_merge()| function except that it requires 
%the type T to have well defined  \verb| < | and \verb| > | operators.
%
%The second function, based on  \verb|MIAMI_single_merge_cmp()|,
%\begin{verbatim}
%template<class T>
%
%template<class T>               
%AMI_err AMI_partition_and_merge_stream_cmp(AMI_STREAM<T> *instream,
%                                           AMI_STREAM<T> *outstream,
%                                           int (*cmp)(CONST T&, CONST T&)
%                                           )
%\end{verbatim}
%has the same requirements as the \verb|MIAMI_single_merge_cmp()| function.
%
%The third function,   based on  \verb|MIAMI_single_merge_Key()|,
%\begin{verbatim}
%template<class T, class KEY>
%AMI_err AMI_partition_and_merge_Key(AMI_STREAM<T> *instream,
%                                   AMI_STREAM<T> *outstream, 
%                                              int keyoffset, 
%                                               KEY dummykey)
%\end{verbatim}
%provides similar functionality as \verb|AMI_partition_and_merge()|
%except that it is  uses KEY and {\tt keyoffset}
%information while merging and sorting, as indicated above.
%


%%% THIS IS SOMETHING THAT SHOULD MAYBE GO IN LATER IN THE IMPLEMENTATION
%%% SECTION (and the distribution)

%The function
%\begin{verbatim}
%template<class T, class KEY>
%AMI_err AMI_replacement_selection_and_merge_Key(AMI_STREAM<T> *instream,
%                                               AMI_STREAM<T> *outstream, 
%                                               int keyoffset,
%                                               KEY dummykey)
%\end{verbatim}
%is the same as \verb|AMI_partition_and_merge_Key()| above, except that
%it uses a fundamentally different run formation algorithm. The 
%\verb|AMI_replacement_selection_and_merge_Key()| function uses
%the replacement selection (Algorithm R in Knuth's Vol 3, Section 5.4.1)
%technique to form runs. This technique is known to produce runs that
%are twice as long and half as many as the ordinary run formation
%technique used in  \verb|AMI_partition_and_merge_Key()| on average,
%and so has the potential of reducing the number of merge passes.
%But the internal memory performance of replacement selection may
%be a little worse than the internal memory performance of the ordinary
%run formation technique; so what is eventually better could very well
%depend on various parameters.


\subsection{Distribution}
\label{sec:ref-ami-dist}
\index{Distribution}

\tobewritten


\subsection{Comparison Sorting}
\label{sec:ref-ami-sort}

\index{sorting!comparison|(}

TPIE provides a sort function \verb|AMI_sort()| based on merge
sort. Version \version~of TPIE also contains alpha versions of a new
sorting function \verb|AMI_optimized_sort()| which is also based on merge
sort. It is planned that after thorough testing this function will be the
default TPIE \verb|AMI_sort()| function. Section~\ref{sec:ref-imp-ami-sort}
contains a discussion of the difference between the two functions. In the
future a number of other sort algorithms will be implemented and it is the
intention that when calling \verb|AMI_sort()| TPIE should automatically
select the best sorting algorithm for the given hardware platform.

\subsubsection{AMI\_sort}

In order to provide maximum flexibility to programmers, \verb|AMI_sort()|
has three polymorphs.

\begin{verbatim}
  AMI_err AMI_sort(AMI_STREAM<T> *instream, AMI_STREAM<T> *outstream)
  AMI_err AMI_sort(AMI_STREAM<T> *instream, AMI_STREAM<T> *outstream,
                   int (*cmp)(CONST T&, CONST T&));
  AMI_err AMI_sort(AMI_STREAM<T> *instream, AMI_STREAM<T> *outstream,
                   comparator<T> *cmp)
\end{verbatim}

All three polymorphs take an argument \verb|instream|, which is a pointer
to the input stream, and \verb|outstream|, which is a pointer to the output
stream to which the sorted results are to be written. The first polymorph
takes no additional arguments and the \verb|<| operator is used in order to
determine the relative order of two input objects. Thus, the type \verb|T|
of objects in the stream must have a member \verb|operator<|.

The second polymorph relies on a user supplied comparison function, similar
to that used in the familiar C library function \verb|qsort()| and in one
of the polymorphs of \verb|AMI_merge()|. It is often useful to use a
comparison function when the type of the objects being sorted has several
fields, and one sometimes wish to sort on one field and sometimes on
another.  Two different comparison functions can be defined, eliminating
the need to provide a \verb|<| operator that is compile-time bound to
perform comparisons in a particular way.

The final polymorph of \verb|AMI_sort()| relies on a comparator
class.\comment{LA: Function object change.}
Instead of defining a comparison function, the programmer defines a
comparator class, which has a member function
\begin{verbatim}
    int compare(const T& t1, const T& t2);
\end{verbatim}
which behaves exactly as the comparison function described above.

%Examples of comparison based sorting appear in
%Section~\ref{sec:cmp-sorting} as well as in the test applications that
%appear in the TPIE distribution.  Section~\ref{sec:list-ranking}
%illustrates the use of multiple comparison functions to sort streams of
%objects in different ways.

\subsubsection{AMI\_optimized\_sort}

\verb|AMI_optimized_sort()| also have three polymorphs.\comment{LA: We need
to add a comparator class polymorph. That will also make it possible to
clean up the code in ami\_optmized\_merge.h}

\begin{verbatim}
  AMI_err AMI_optimized_sort(AMI_STREAM<T> *instream, AMI_STREAM<T>
                             *outstream) 
  AMI_err AMI_optimized_sort(AMI_STREAM<T> *instream,
                             AMI_STREAM<T> *outstream, int (*cmp)(CONST T&,
                             CONST T&)); 
  AMI_err AMI_optimized_sort(AMI_STREAM<T> *instream,
                             AMI_STREAM<T> *outstream, 
                             int keyoffset, KEY dummy);
\end{verbatim}

As for \verb|AMI_sort()| the first two polymorphs rely on \verb|<| and user
supplied comparison functions, respectively. Similar to one of the
\verb|AMI_merge()| polymorphs, the third polymorphs assumes that the
objects in the input stream have a field with well-defined \verb|<|
operator, and that the ordering of the object is to be based on the total
order of this field. \verb|keyoffset| is the offset within an object of
type T of this key field and \verb|dummy| is a (any) variable of type
\verb|KEY|.\comment{LA: Something about this being for C++ reasons?}

\index{sorting!comparison|)}

\subsection{Key Bucket Sorting}
\label{sec:ref-ami-kb-sort}

\index{sorting!key bucket|(}

\tobeextended

\begin{verbatim}
AMI_err AMI_kb_dist()
\end{verbatim}

\begin{verbatim}
AMI_err AMI_kb_sort()
\end{verbatim}

\begin{verbatim}
AMI_err AMI_kb_dist_key()
\end{verbatim}

\begin{verbatim}
AMI_err AMI_kb_sort_key()
\end{verbatim}
\index{sorting!key bucket|)}


\subsection{General Permuting}
\label{sec:ref-ami-gp}

\index{permutation!general|(}

\tobeextended

\begin{verbatim}
AMI_err AMI_general_permute(AMI_STREAM<T> *instream, 
                            AMI_STREAM<T> *outstream, 
                            AMI_gen_perm_object *gpo);
\end{verbatim}
\index{permutation!general|)}

\subsection{Bit Permuting}
\label{sec:ref-ami-bp}

\index{permutation!bit|(}

\tobeextended

\begin{verbatim}
AMI_err AMI_BMMC_permute(AMI_STREAM<T> *instream, 
                         AMI_STREAM<T> *outstream, 
                         AMI_bit_perm_object *bpo);
\end{verbatim}
\index{permutation!bit|)}

\subsection{Dense Matrices}
\label{sec:ref-ami-matrix}

\index{matrices!dense|(}
\index{matrices!dense|)}

\tobewritten


\subsection{Sparse Matrices}
\label{sec:ref-ami-sm}

\index{matrices!sparse|(}
\index{matrices!sparse|)}

\tobewritten


\subsection{Elementwise and Scalar Elementwise Arithmetic}
\label{sec:ref-ami-arith}

\index{elementwise arithmetic|(} 

Elementwise arithmetic on streams is done through the use of scan
management objects designed specifically for this purpose.  They are
used as parameters to \verb|AMI_scan()|, just like any other scan
management object.  To operate on two input streams and produce a
single output stream, each of whose elements is computed from the
corresponding elements of the input streams, we use a scan management
object of class \verb|AMI_scan_op<T>|, where \verb|op| is one of
\verb|add|, \verb|sub|, \verb|mult|, or \verb|div|.  As long as
\verb|T| is a type that has the necessary operator (i.e. \verb|+|,
\verb|-|, \verb|*|, or \verb|/|) then the corresponding class
\verb|AMI_scan_op<T>| can be instantiated.

If the two input streams are not of the same length, then elementwise
operations will only continue as long as there is data available from
the shorter of the two streams.  Thus, the output stream will be
exactly as long as the shorter of the two input streams.  No attempt
is made to use an identity if one stream runs out before the other.

A related class of scan management object,
\verb|AMI_scan_scalar_op<T>| produces an output object equal to
\verb|t op s| for each input object \verb|t| and some scalar |s|.
The value of \verb|s| is set at the time the object is constructed,
not at initialization time (i.e. when \verb|initialize()| is called.
For example, the declaration
\begin{verbatim}
    AMI_scan_scalar_div<double> ssd(17.0);
\end{verbatim}
declares a scan management object that will produce a stream of output
each element of which is one seventeenth the corresponding input.

Since dense matrices with elements of type \verb|T| are a subclass of
\verb|AMI_STREAM<T>|, elementwise arithmetic operations on dense
matrices are implemented on top of scans using elementwise arithmetic
operations.

\index{elementwise arithmetic|)}


\subsection{Stacks}
\label{sec:ref-ami-stack}

\index{stacks|(}

External stacks are implemented through the templated class
\verb|AMI_stack<T>|, which is a subclass of \verb|AMI_STREAM<T>|. In
addition to the normal operations operations on streams, an
\verb|AMI_stack<T>| has member functions \verb|AMI_err push(const &T t)|
and \verb|AMI_err pop(T **ppt)|. The former appends a copy of the object
\verb|t| to the end of the stream, increasing it's length by one. The
latter removes the last object from the stream, decreasing it's length by
one and storing a pointer to the removed object in the space pointed to by
\verb|ppt|.

\index{stacks|)}


\subsection{Distribution Sweeping}
\label{sec:ref-ami-distsweep}

\comment{LA: index - Distribution sweeping}

\tobewritten
%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
