// This file was generated by factory_helpers.gen.py, DO NOT EDIT
#ifndef __TPIE_PIPELINING_FACTORY_HELPERS_H__
#define __TPIE_PIPELINING_FACTORY_HELPERS_H__

#include <tpie/pipelining/factory_base.h>

namespace tpie {
namespace pipelining {

///////////////////////////////////////////////////////////////////////////////
/// \class factory_0
/// Push segment factory for 0-argument generator.
///////////////////////////////////////////////////////////////////////////////
template <template <typename dest_t> class R>
struct factory_0 : public factory_base {
	template<typename dest_t>
	struct generated {
		typedef R<dest_t> type;
	};

	template <typename dest_t>
	inline R<dest_t> construct(const dest_t & dest) const {
		R<dest_t> r(dest);
		this->init_segment(r);
		return r;
	}
};

///////////////////////////////////////////////////////////////////////////////
/// \class tempfactory_0
/// Push segment factory for 0-argument templated generator.
///////////////////////////////////////////////////////////////////////////////
template <typename Holder>
struct tempfactory_0 : public factory_base {
	template<typename dest_t>
	struct generated {
		typedef typename Holder::template type<dest_t> type;
	};

	template <typename dest_t>
	inline typename Holder::template type<dest_t> construct(const dest_t & dest) const {
		typename Holder::template type<dest_t> r(dest);
		this->init_segment(r);
		return r;
	}
};

///////////////////////////////////////////////////////////////////////////////
/// \class factory_1
/// Push segment factory for 1-argument generator.
///////////////////////////////////////////////////////////////////////////////
template <template <typename dest_t> class R, typename T1>
struct factory_1 : public factory_base {
	template<typename dest_t>
	struct generated {
		typedef R<dest_t> type;
	};

	inline factory_1(T1 t1) : t1(t1) {}

	template <typename dest_t>
	inline R<dest_t> construct(const dest_t & dest) const {
		R<dest_t> r(dest, t1);
		this->init_segment(r);
		return r;
	}
private:
	T1 t1;
};

///////////////////////////////////////////////////////////////////////////////
/// \class tempfactory_1
/// Push segment factory for 1-argument templated generator.
///////////////////////////////////////////////////////////////////////////////
template <typename Holder, typename T1>
struct tempfactory_1 : public factory_base {
	template<typename dest_t>
	struct generated {
		typedef typename Holder::template type<dest_t> type;
	};

	inline tempfactory_1(T1 t1) : t1(t1) {}

	template <typename dest_t>
	inline typename Holder::template type<dest_t> construct(const dest_t & dest) const {
		typename Holder::template type<dest_t> r(dest, t1);
		this->init_segment(r);
		return r;
	}
private:
	T1 t1;
};

///////////////////////////////////////////////////////////////////////////////
/// \class factory_2
/// Push segment factory for 2-argument generator.
///////////////////////////////////////////////////////////////////////////////
template <template <typename dest_t> class R, typename T1, typename T2>
struct factory_2 : public factory_base {
	template<typename dest_t>
	struct generated {
		typedef R<dest_t> type;
	};

	inline factory_2(T1 t1, T2 t2) : t1(t1), t2(t2) {}

	template <typename dest_t>
	inline R<dest_t> construct(const dest_t & dest) const {
		R<dest_t> r(dest, t1, t2);
		this->init_segment(r);
		return r;
	}
private:
	T1 t1;
	T2 t2;
};

///////////////////////////////////////////////////////////////////////////////
/// \class tempfactory_2
/// Push segment factory for 2-argument templated generator.
///////////////////////////////////////////////////////////////////////////////
template <typename Holder, typename T1, typename T2>
struct tempfactory_2 : public factory_base {
	template<typename dest_t>
	struct generated {
		typedef typename Holder::template type<dest_t> type;
	};

	inline tempfactory_2(T1 t1, T2 t2) : t1(t1), t2(t2) {}

	template <typename dest_t>
	inline typename Holder::template type<dest_t> construct(const dest_t & dest) const {
		typename Holder::template type<dest_t> r(dest, t1, t2);
		this->init_segment(r);
		return r;
	}
private:
	T1 t1;
	T2 t2;
};

///////////////////////////////////////////////////////////////////////////////
/// \class factory_3
/// Push segment factory for 3-argument generator.
///////////////////////////////////////////////////////////////////////////////
template <template <typename dest_t> class R, typename T1, typename T2, typename T3>
struct factory_3 : public factory_base {
	template<typename dest_t>
	struct generated {
		typedef R<dest_t> type;
	};

	inline factory_3(T1 t1, T2 t2, T3 t3) : t1(t1), t2(t2), t3(t3) {}

	template <typename dest_t>
	inline R<dest_t> construct(const dest_t & dest) const {
		R<dest_t> r(dest, t1, t2, t3);
		this->init_segment(r);
		return r;
	}
private:
	T1 t1;
	T2 t2;
	T3 t3;
};

///////////////////////////////////////////////////////////////////////////////
/// \class tempfactory_3
/// Push segment factory for 3-argument templated generator.
///////////////////////////////////////////////////////////////////////////////
template <typename Holder, typename T1, typename T2, typename T3>
struct tempfactory_3 : public factory_base {
	template<typename dest_t>
	struct generated {
		typedef typename Holder::template type<dest_t> type;
	};

	inline tempfactory_3(T1 t1, T2 t2, T3 t3) : t1(t1), t2(t2), t3(t3) {}

	template <typename dest_t>
	inline typename Holder::template type<dest_t> construct(const dest_t & dest) const {
		typename Holder::template type<dest_t> r(dest, t1, t2, t3);
		this->init_segment(r);
		return r;
	}
private:
	T1 t1;
	T2 t2;
	T3 t3;
};

///////////////////////////////////////////////////////////////////////////////
/// \class factory_4
/// Push segment factory for 4-argument generator.
///////////////////////////////////////////////////////////////////////////////
template <template <typename dest_t> class R, typename T1, typename T2, typename T3, typename T4>
struct factory_4 : public factory_base {
	template<typename dest_t>
	struct generated {
		typedef R<dest_t> type;
	};

	inline factory_4(T1 t1, T2 t2, T3 t3, T4 t4) : t1(t1), t2(t2), t3(t3), t4(t4) {}

	template <typename dest_t>
	inline R<dest_t> construct(const dest_t & dest) const {
		R<dest_t> r(dest, t1, t2, t3, t4);
		this->init_segment(r);
		return r;
	}
private:
	T1 t1;
	T2 t2;
	T3 t3;
	T4 t4;
};

///////////////////////////////////////////////////////////////////////////////
/// \class tempfactory_4
/// Push segment factory for 4-argument templated generator.
///////////////////////////////////////////////////////////////////////////////
template <typename Holder, typename T1, typename T2, typename T3, typename T4>
struct tempfactory_4 : public factory_base {
	template<typename dest_t>
	struct generated {
		typedef typename Holder::template type<dest_t> type;
	};

	inline tempfactory_4(T1 t1, T2 t2, T3 t3, T4 t4) : t1(t1), t2(t2), t3(t3), t4(t4) {}

	template <typename dest_t>
	inline typename Holder::template type<dest_t> construct(const dest_t & dest) const {
		typename Holder::template type<dest_t> r(dest, t1, t2, t3, t4);
		this->init_segment(r);
		return r;
	}
private:
	T1 t1;
	T2 t2;
	T3 t3;
	T4 t4;
};

///////////////////////////////////////////////////////////////////////////////
/// \class factory_5
/// Push segment factory for 5-argument generator.
///////////////////////////////////////////////////////////////////////////////
template <template <typename dest_t> class R, typename T1, typename T2, typename T3, typename T4, typename T5>
struct factory_5 : public factory_base {
	template<typename dest_t>
	struct generated {
		typedef R<dest_t> type;
	};

	inline factory_5(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5) : t1(t1), t2(t2), t3(t3), t4(t4), t5(t5) {}

	template <typename dest_t>
	inline R<dest_t> construct(const dest_t & dest) const {
		R<dest_t> r(dest, t1, t2, t3, t4, t5);
		this->init_segment(r);
		return r;
	}
private:
	T1 t1;
	T2 t2;
	T3 t3;
	T4 t4;
	T5 t5;
};

///////////////////////////////////////////////////////////////////////////////
/// \class tempfactory_5
/// Push segment factory for 5-argument templated generator.
///////////////////////////////////////////////////////////////////////////////
template <typename Holder, typename T1, typename T2, typename T3, typename T4, typename T5>
struct tempfactory_5 : public factory_base {
	template<typename dest_t>
	struct generated {
		typedef typename Holder::template type<dest_t> type;
	};

	inline tempfactory_5(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5) : t1(t1), t2(t2), t3(t3), t4(t4), t5(t5) {}

	template <typename dest_t>
	inline typename Holder::template type<dest_t> construct(const dest_t & dest) const {
		typename Holder::template type<dest_t> r(dest, t1, t2, t3, t4, t5);
		this->init_segment(r);
		return r;
	}
private:
	T1 t1;
	T2 t2;
	T3 t3;
	T4 t4;
	T5 t5;
};

///////////////////////////////////////////////////////////////////////////////
/// \class factory_6
/// Push segment factory for 6-argument generator.
///////////////////////////////////////////////////////////////////////////////
template <template <typename dest_t> class R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
struct factory_6 : public factory_base {
	template<typename dest_t>
	struct generated {
		typedef R<dest_t> type;
	};

	inline factory_6(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6) : t1(t1), t2(t2), t3(t3), t4(t4), t5(t5), t6(t6) {}

	template <typename dest_t>
	inline R<dest_t> construct(const dest_t & dest) const {
		R<dest_t> r(dest, t1, t2, t3, t4, t5, t6);
		this->init_segment(r);
		return r;
	}
private:
	T1 t1;
	T2 t2;
	T3 t3;
	T4 t4;
	T5 t5;
	T6 t6;
};

///////////////////////////////////////////////////////////////////////////////
/// \class tempfactory_6
/// Push segment factory for 6-argument templated generator.
///////////////////////////////////////////////////////////////////////////////
template <typename Holder, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
struct tempfactory_6 : public factory_base {
	template<typename dest_t>
	struct generated {
		typedef typename Holder::template type<dest_t> type;
	};

	inline tempfactory_6(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6) : t1(t1), t2(t2), t3(t3), t4(t4), t5(t5), t6(t6) {}

	template <typename dest_t>
	inline typename Holder::template type<dest_t> construct(const dest_t & dest) const {
		typename Holder::template type<dest_t> r(dest, t1, t2, t3, t4, t5, t6);
		this->init_segment(r);
		return r;
	}
private:
	T1 t1;
	T2 t2;
	T3 t3;
	T4 t4;
	T5 t5;
	T6 t6;
};

///////////////////////////////////////////////////////////////////////////////
/// \class termfactory_0
/// Push segment factory for 0-argument terminator.
///////////////////////////////////////////////////////////////////////////////
template <typename R>
struct termfactory_0 : public factory_base {
	typedef R generated_type;

	inline R construct() const {
		R r;
		this->init_segment(r);
		return r;
	}
};

///////////////////////////////////////////////////////////////////////////////
/// \class temptermfactory_0
/// Push segment factory for 0-argument templated terminator.
///////////////////////////////////////////////////////////////////////////////
template <typename Holder>
struct temptermfactory_0 : public factory_base {
	typedef typename Holder::type generated_type;

	inline typename Holder::type construct() const {
		typename Holder::type r;
		this->init_segment(r);
		return r;
	}
};

///////////////////////////////////////////////////////////////////////////////
/// \class termfactory_1
/// Push segment factory for 1-argument terminator.
///////////////////////////////////////////////////////////////////////////////
template <typename R, typename T1>
struct termfactory_1 : public factory_base {
	typedef R generated_type;

	inline termfactory_1(T1 t1) : t1(t1) {}

	inline R construct() const {
		R r(t1);
		this->init_segment(r);
		return r;
	}
private:
	T1 t1;
};

///////////////////////////////////////////////////////////////////////////////
/// \class temptermfactory_1
/// Push segment factory for 1-argument templated terminator.
///////////////////////////////////////////////////////////////////////////////
template <typename Holder, typename T1>
struct temptermfactory_1 : public factory_base {
	typedef typename Holder::type generated_type;

	inline temptermfactory_1(T1 t1) : t1(t1) {}

	inline typename Holder::type construct() const {
		typename Holder::type r(t1);
		this->init_segment(r);
		return r;
	}
private:
	T1 t1;
};

///////////////////////////////////////////////////////////////////////////////
/// \class termfactory_2
/// Push segment factory for 2-argument terminator.
///////////////////////////////////////////////////////////////////////////////
template <typename R, typename T1, typename T2>
struct termfactory_2 : public factory_base {
	typedef R generated_type;

	inline termfactory_2(T1 t1, T2 t2) : t1(t1), t2(t2) {}

	inline R construct() const {
		R r(t1, t2);
		this->init_segment(r);
		return r;
	}
private:
	T1 t1;
	T2 t2;
};

///////////////////////////////////////////////////////////////////////////////
/// \class temptermfactory_2
/// Push segment factory for 2-argument templated terminator.
///////////////////////////////////////////////////////////////////////////////
template <typename Holder, typename T1, typename T2>
struct temptermfactory_2 : public factory_base {
	typedef typename Holder::type generated_type;

	inline temptermfactory_2(T1 t1, T2 t2) : t1(t1), t2(t2) {}

	inline typename Holder::type construct() const {
		typename Holder::type r(t1, t2);
		this->init_segment(r);
		return r;
	}
private:
	T1 t1;
	T2 t2;
};

///////////////////////////////////////////////////////////////////////////////
/// \class termfactory_3
/// Push segment factory for 3-argument terminator.
///////////////////////////////////////////////////////////////////////////////
template <typename R, typename T1, typename T2, typename T3>
struct termfactory_3 : public factory_base {
	typedef R generated_type;

	inline termfactory_3(T1 t1, T2 t2, T3 t3) : t1(t1), t2(t2), t3(t3) {}

	inline R construct() const {
		R r(t1, t2, t3);
		this->init_segment(r);
		return r;
	}
private:
	T1 t1;
	T2 t2;
	T3 t3;
};

///////////////////////////////////////////////////////////////////////////////
/// \class temptermfactory_3
/// Push segment factory for 3-argument templated terminator.
///////////////////////////////////////////////////////////////////////////////
template <typename Holder, typename T1, typename T2, typename T3>
struct temptermfactory_3 : public factory_base {
	typedef typename Holder::type generated_type;

	inline temptermfactory_3(T1 t1, T2 t2, T3 t3) : t1(t1), t2(t2), t3(t3) {}

	inline typename Holder::type construct() const {
		typename Holder::type r(t1, t2, t3);
		this->init_segment(r);
		return r;
	}
private:
	T1 t1;
	T2 t2;
	T3 t3;
};

///////////////////////////////////////////////////////////////////////////////
/// \class termfactory_4
/// Push segment factory for 4-argument terminator.
///////////////////////////////////////////////////////////////////////////////
template <typename R, typename T1, typename T2, typename T3, typename T4>
struct termfactory_4 : public factory_base {
	typedef R generated_type;

	inline termfactory_4(T1 t1, T2 t2, T3 t3, T4 t4) : t1(t1), t2(t2), t3(t3), t4(t4) {}

	inline R construct() const {
		R r(t1, t2, t3, t4);
		this->init_segment(r);
		return r;
	}
private:
	T1 t1;
	T2 t2;
	T3 t3;
	T4 t4;
};

///////////////////////////////////////////////////////////////////////////////
/// \class temptermfactory_4
/// Push segment factory for 4-argument templated terminator.
///////////////////////////////////////////////////////////////////////////////
template <typename Holder, typename T1, typename T2, typename T3, typename T4>
struct temptermfactory_4 : public factory_base {
	typedef typename Holder::type generated_type;

	inline temptermfactory_4(T1 t1, T2 t2, T3 t3, T4 t4) : t1(t1), t2(t2), t3(t3), t4(t4) {}

	inline typename Holder::type construct() const {
		typename Holder::type r(t1, t2, t3, t4);
		this->init_segment(r);
		return r;
	}
private:
	T1 t1;
	T2 t2;
	T3 t3;
	T4 t4;
};

///////////////////////////////////////////////////////////////////////////////
/// \class termfactory_5
/// Push segment factory for 5-argument terminator.
///////////////////////////////////////////////////////////////////////////////
template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5>
struct termfactory_5 : public factory_base {
	typedef R generated_type;

	inline termfactory_5(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5) : t1(t1), t2(t2), t3(t3), t4(t4), t5(t5) {}

	inline R construct() const {
		R r(t1, t2, t3, t4, t5);
		this->init_segment(r);
		return r;
	}
private:
	T1 t1;
	T2 t2;
	T3 t3;
	T4 t4;
	T5 t5;
};

///////////////////////////////////////////////////////////////////////////////
/// \class temptermfactory_5
/// Push segment factory for 5-argument templated terminator.
///////////////////////////////////////////////////////////////////////////////
template <typename Holder, typename T1, typename T2, typename T3, typename T4, typename T5>
struct temptermfactory_5 : public factory_base {
	typedef typename Holder::type generated_type;

	inline temptermfactory_5(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5) : t1(t1), t2(t2), t3(t3), t4(t4), t5(t5) {}

	inline typename Holder::type construct() const {
		typename Holder::type r(t1, t2, t3, t4, t5);
		this->init_segment(r);
		return r;
	}
private:
	T1 t1;
	T2 t2;
	T3 t3;
	T4 t4;
	T5 t5;
};

///////////////////////////////////////////////////////////////////////////////
/// \class termfactory_6
/// Push segment factory for 6-argument terminator.
///////////////////////////////////////////////////////////////////////////////
template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
struct termfactory_6 : public factory_base {
	typedef R generated_type;

	inline termfactory_6(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6) : t1(t1), t2(t2), t3(t3), t4(t4), t5(t5), t6(t6) {}

	inline R construct() const {
		R r(t1, t2, t3, t4, t5, t6);
		this->init_segment(r);
		return r;
	}
private:
	T1 t1;
	T2 t2;
	T3 t3;
	T4 t4;
	T5 t5;
	T6 t6;
};

///////////////////////////////////////////////////////////////////////////////
/// \class temptermfactory_6
/// Push segment factory for 6-argument templated terminator.
///////////////////////////////////////////////////////////////////////////////
template <typename Holder, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
struct temptermfactory_6 : public factory_base {
	typedef typename Holder::type generated_type;

	inline temptermfactory_6(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6) : t1(t1), t2(t2), t3(t3), t4(t4), t5(t5), t6(t6) {}

	inline typename Holder::type construct() const {
		typename Holder::type r(t1, t2, t3, t4, t5, t6);
		this->init_segment(r);
		return r;
	}
private:
	T1 t1;
	T2 t2;
	T3 t3;
	T4 t4;
	T5 t5;
	T6 t6;
};

} // namespace pipelining
} // namespace tpie

#endif // __TPIE_PIPELINING_FACTORY_HELPERS_H__
