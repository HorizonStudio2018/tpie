/**
\page pipelining-concepts Pipelining concepts

\section sec_pipe_segment Pipe segments

A pipe segment is a class that derives from tpie::pipelining::pipe_segment and
either overrides \c go(), implements \c push() or implements \c pull() and
\c can_pull(). In the first case, the pipe segment is called an
<em>initiator</em>; in the second case, it is called a <em>push segment</em>,
and in the third case, it is called a <em>pull segment</em>.

- A pipe segment SHOULD aggregate the pipe segment(s) it pushes to or pulls from,
  and thus a pipe segment is usually templated on its destination type.

- A pipe segment SHOULD be copyable such that any other copyable pipe segment
  may aggregate it.

- A push/pull segment MUST declare a public typedef \c item_type, the type of
  item accepted by \c push or returned by \c pull. This is used by built-in type
  generic segments such as the sorter or the reverser.

- At runtime, it MUST declare the pipe segment(s) it pushes to or pulls from by
  calling the methods \c pipe_segment::add_push_destination and
  \c pipe_segment::add_pull_destination.

- At runtime, it SHOULD declare a name by calling the methods
  \c pipe_segment::set_name with \c tpie::pipelining::PRIORITY_INSIGNIFICANT or
  \c PRIORITY_SIGNIFICANT as the second parameter (depending whether the
  segment does significant or insignificant work; the lines are quite blurry).

Thus, a \c pipe_segment implementation of a push segment may look as follows:

\code
template <typename dest_t>
class hello_world_type : public tpie::pipelining::pipe_segment {
	dest_t dest;
public:
	typedef tpie::memory_size_type item_type;

	hello_world_type(dest_t dest)
		: dest(dest)
	{
		add_push_destination(dest);
		set_name("My first pipe segment",
		         tpie::pipelining::PRIORITY_SIGNIFICANT);
	}

	void push(const item_type & item) {
		if ((item % 2) == 0) {
			dest.push(item/2);
		} else {
			dest.push(3*item+1);
		}
	}
};
\endcode

\section sec_pipelining_factory Factories

In order to instantiate pipe_segment implementations, we need a factory.
Usually, the built-in factories contained in \c factory_helpers.h will suffice:

\code
typedef tpie::pipelining::factory_0<hello_world_type> hello_world_factory;
\endcode

but in some cases it is helpful to implement one's own factory.

We could implement a \c hello_world_factory as follows:

\code
class hello_world_factory : public tpie::pipelining::factory_base {
public:
	template <typename dest_t>
	struct generated {
		typedef hello_world_type<dest_t> type;
	};

	template <typename dest_t>
	hello_world_type<dest_t> construct(const dest_t & dest) {
		hello_world_type<dest_t> hw(dest);
		this->init_segment(hw);
		return hw;
	}
};
\endcode

For a terminating pipe_segment, which doesn't have a destination, we would
implement a so called termfactory as follows:

\code
class goodbye_world_type : public tpie::pipelining::pipe_segment {
public:
	typedef tpie::memory_size_type item_type;
	void push(item_type) {}
};

class goodbye_world_factory : public tpie::pipelining::factory_base {
public:
	typedef goodbye_world generated_type;

	goodbye_world_type construct() {
		goodbye_world_type gw;
		this->init_segment(gw);
		return gw;
	}
};
\endcode

\section sec_pipe_base Factory concatenation

To use the above defined factories, we might write the following:

\code
using namespace tpie;
using namespace tpie::pipelining;
factory_1<input_t, file_stream<memory_size_type> &> fact0(inputstream);
hello_world_factory fact1;
goodbye_world_factory fact2;
pipeline p = fact0.construct(fact1.construct(fact2.construct()));
p();
\endcode

However, this is tedious, and so the pipelining framework provides several
helper classes to ease the construction of pipelines, namely the descendants of
\c pipe_base which are called \c pipe_begin, \c pipe_middle and \c pipe_end.

\code
inline pipe_middle<factory_0<hello_world_type> >
hello_world() {
	return factory_0<hello_world_type>();
}

inline pipe_end<termfactory_0<goodbye_world_type> >
goodbye_world() {
	return termfactory_0<goodbye_world_type>();
}
\endcode

which we would use as follows:
\code
using namespace tpie;
using namespace tpie::pipelining;
pipeline p = input(inputstream) | hello_world() | goodbye_world();
p();
\endcode

The three terms that are piped together have types \c pipe_begin,
\c pipe_middle and \c pipe_end respectively. As one might expect, piping
together a \c pipe_begin and a \c pipe_middle yields a new \c pipe_begin, and
piping together a \c pipe_begin and a \c pipe_end yields a pipeline object
(actually a \c pipeline_impl object).

\section sec_phases Pipeline phases

Consider the following implementation of a reverser:

\code
template <typename dest_t>
class reverser_type : public tpie::pipelining::pipe_segment {
	tpie::stack<point3d> points;
	dest_t dest;
public:
	typedef point3d item_type;

	void push(point3d p) {
		points.push(p);
		set_name("Reverser",
		         tpie::pipelining::PRIORITY_SIGNIFICANT);
	}

	void end() {
		pipe_segment::end();
		while (!points.empty()) {
			dest.push(points.pop());
		}
	}
};
\endcode

This implementation seems innocious at first, but it is in fact very wasteful.
Note that the reverser needs to know the entire stream before it can push
anything to its destination. This means that when all items have been pushed to
it, we could as well deallocate all the item buffers that earlier pipe segments
may have used while processing. As well, we could have waited until the stack
was ready to push before initializing later pipe segments in the pipeline.

This is what pipelining phases are for. Phases are collections of pipe segments
that do not have to operate synchronously. Pipe segments may establish an
ordering of pipelining phases by adding dependencies to pipe segments in other
phases. Let us implement a reverser using phases.

\code
template <typename dest_t>
class reverser_type_1 : public tpie::pipelining::pipe_segment {
	tpie::temp_file tmpfile;
	tpie::auto_ptr<tpie::stack<point3d> > points;
	dest_t dest;
public:
	typedef point3d item_type;

	reverser_type_1(dest_t dest) {
		dest.set_first(*this);
	}

	void begin() {
		pipe_segment::begin();
		tmpfile.set_persistent(true);
		points.reset(new tpie::stack<point3d>(tmpfile));
		forward<std::string>("stack", tmpfile.path());
	}

	void push(point3d p) {
		points->write(p);
	}

	void end() {
		pipe_segment::end();
		points.reset();
	}
};

template <typename dest_t>
class reverser_type_2 : public tpie::pipelining::pipe_segment {
	tpie::temp_file tmpfile;
	tpie::auto_ptr<tpie::stack<point3d> > points;
	dest_t dest;
public:
	reverser_type_2(dest_t dest) {
		add_push_destination(dest);
	}

	void set_first(pipe_segment & first) {
		add_dependency(first);
	}

	void begin() {
		pipe_segment::begin();
		tmpfile.set_path(fetch<std::string>("stack"));
		points.reset(new tpie::stack<point3d>(tmpfile));
	}

	void go(progress_indicator_base & pi) {
		pi.init(points->size());
		while (!points->empty()) {
			dest.push(points->pop());
			pi.step();
		}
		pi.done();
	}

	void end() {
		pipe_segment::end();
		points.reset();
		tmpfile.free();
	}
};
\endcode
*/
