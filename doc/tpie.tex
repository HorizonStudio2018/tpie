%%
%% Copyright (c) 1994, 1995 Darren Vengroff
%%
%% File: tpie.texi
%% Author: Darren Vengroff <darrenv@eecs.umich.edu>
%% Created: 6/21/95
%%
%% Copies and modified from tpie.texi.
%%
%% $Id: tpie.tex,v 1.1 1995-06-30 21:04:33 darrenv Exp $
%%

\documentstyle[11pt,html,makeidx]{book}


% normal margins for US-size paper
\setlength{\topmargin}{-.5in}   
\setlength{\oddsidemargin}{.1in} % distance from left edge of page to text
\setlength{\evensidemargin}{.1in} % distance from left edge of page to text
\setlength{\textwidth}{6.3in}
\setlength{\textheight}{9in}


\makeindex


% Additions to makeidx.sty

%\makeatletter
%\@ifundefined{alsoname}%
%   {\def\alsoname{also}}{}

%\def\seealso#1#2{{\em \seename\ \alsoname\/} #1}
%\makeatother


\newcommand{\edition}{0.7.1}
\newcommand{\version}{0.7.1a}

\newcommand{\gxxversion}{2.7.0}

%% Commands to mimic some that latexinfo has:



%% End of LaTeXinfo-like commands.

\begin{document}

\bibliographystyle{abbrv}

\title{TPIE User Manual and Reference}
\author{Darren Erik Vengroff}
\date{{\bf DRAFT} of \today}

\maketitle

\begin{titlepage}

\vspace*{5 ex}

\centerline{\Large {\bf DRAFT} of \today}

\vspace{\fill}


\noindent TPIE User Manual and Reference

\noindent Edition \edition, for TPIE version \version.

\vspace{2 ex}

\noindent Copyright \copyright 1994, 1995 Darren Erik Vengroff

\vspace{2 ex}

The programs described in this manual are free software; you can
redistribute them and/or modify them under the terms of the GNU General
Public License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.

This manual and the programs it describes are distributed in the hope
that they will be useful, but WITHOUT ANY WARRANTY; without even the
implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE.  See the GNU General Public License (Appendix~\ref{app:gpl})
for more details.

You should have received a copy of the GNU General Public License
along with this manual; if not, write to the Free Software Foundation,
Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
\end{titlepage}

\tableofcontents

\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction}

This manual describes TPIE, a Transparent Parallel I/O Environment,
designed to allow programmers to write high performance I/O-efficient
programs for a variety of platforms.

{\bf This manual, like the whole of the TPIE project, is a work in
  progress.}  The author is making it available in in its current state
in the hopes that it will be useful, but without any warrantee
whatsoever.  Please refer to the copyright page at the beginning of
this manual for full details.


\part{User Manual}

\chapter{Overview}

As of today, gigabyte computer systems exist on desktops, and terabyte
systems are not unheard of.  In the not too distant future, systems
designed to manage petabytes of information
will come on-line.  The most important characteristic of such vast
amounts of data is that they cannot possibly be stored in the primary
memories of even the most powerful computers.  Instead, they must be
stored on secondary memory, such as magnetic disks, or tertiary
memory, such as tapes and optical memory.  Compared to CPUs and solid
state random access memory, these devices are extraordinarily slow;
the difference in access time is typically 2 to 5 orders of magnitude.
Because of the low speed of secondary storage, good performance in the
Input/Output (I/O) system that links secondary storage to main memory
and the CPU or CPUs is critical if good performance is to be achieved
overall.  Performance can be further improved if many disks can be
efficiently used in parallel.  Unfortunately, existing I/O systems
generally do not perform adequately~\cite{patt:computer}.

In recent years, computer science theorists have studied the problem
of efficiently using parallel disks\index{parallel disks}
\index{disks!parallel|see{parallel disks}} to solve a variety
of computational problems.  At the same time, a number of parallel I/O
systems have become available, though in most cases they have failed
to take adequate advantage of the insights theorists have had to offer
\cite{cormen:integrate-tr}.  TPIE, a transparent parallel I/O
environment, is designed to bridge the gap between the theory and
practice of parallel I/O systems.  It is intended to demonstrate that
a parallel I/O system can do all of the following simultaneously:
\begin{itemize}
\item Abstract away the details of how I/O is performed so that
  programmers need only deal with a simple high level interface.
\item Implement I/O-optimal paradigms for large scale computation that
  are efficient not only in theory, but also in practice.
\item Remain flexible, allowing programmers to specify the functional
  details of computation taking place within the supported paradigms.
  This will allow a wide variety of algorithms to be implemented
  within the system.
\item Be portable across a variety hardware platforms.
\item Be extensible, so that new features can be easily added later.
\end{itemize}

TPIE is implemented as a set of templated classes and functions in
C++.\index{C++} It also includes a small library and a set of test and
sample applications.

\section{Hardware Platforms}
\index{hardware platforms}

TPIE has been tested on a variety of hardware platforms with a variety
of flavors of UNIX operating systems.  Combinations that have been
tested include:
\begin{itemize}
\item Sun Sparcstation/SunOS 4.x 
\item Sun Sparcstation/Solaris 5.x
\item DEC Alpha/OSF/1 1.x and 2.x
\item HP 9000/HP-UX
\item Intel Pentium/Linux 1.x
\end{itemize}

\chapter{Obtaining and Installing TPIE}

\section{Licensing}

TPIE is available under the terms of the GNU General Public License,
\index{license}
version 2.  A copy of this license appears in Appendix~\ref{app:gpl}.

\section{Where to get TPIE}

The latest version of TPIE, \version, is an alpha test version.  It is
available through the \htmladdnormallink{TPIE WWW Home Page}{%
\begin{rawhtml}
http://www.cs.duke.edu/~dev/tpie_home_page.html
\end{rawhtml}%
}%
\begin{latexonly}
at URL \verb|http://www.cs.duke.edu/~dev/tpie_home_page.html|.
\end{latexonly}

To obtain the TPIE source distribution\index{source distribution}, follow the
pointers form the home page to the distribution itself, which consists
of a gzipped tar file named {\tt tpie-\version.tar.gz}.  Your Web
browser should be capable of downloading this file to your local
machine.

\section{Prerequisites}

\index{GNU software}
\label{sec:gnu-software}

TPIE relies heavily on GNU software distributed by the Free Software
Foundation\index{Free Software Federation}.  In particular, programs
and library listed below are required.  Note that version numbers
indicate the versions used in the development of TPIE version 0.5a.
Later versions of the GNU tools should work as well, though no
guarantees can be made about earlier versions.  This is particularly
true of \verb|g++|.  If you already have the required programs but are
not sure what version they are, try invoking each with the single
command line argument \verb|--version|.

\begin{description}
\item[\verb|g++|] The GNU C++ compiler,
  \index{g++@{\tt g++}}\index{GNU software!gcc@{\tt g++}}
  version \gxxversion.  This is distributed as part of \verb|gcc|, the GNU C
  compiler.
  \index{gcc@{\tt gcc}}\index{GNU software!gcc@{\tt gcc}}
\item[\verb|libg++|] The GNU C++ library,
  \index{libg++@{\tt libg++}}\index{GNU software!libg++@{\tt libg++}}
  version 2.7.  This is not a program, but rather run-time support for
  programs compiled with \verb|g++|.  It is distributed separately
  from \verb|g++|, but if you have one you probably have the other.
\item[\verb|make|] The GNU Make utility, 
  \index{make@{\tt make}}\index{GNU software!make@{\tt make}}
  version 3.71.
\item[\verb|gzip|] The GNU compression/decompression utility, 
  \index{gzip@{\tt gzip}}\index{GNU software!gzip@{\tt gzip}}
  version  1.2.4.  This is needed to uncompress the TPIE 
  distribution.
\item[\verb|tar|] The GNU tape archive utility, 
  \index{tar@{\tt tar}}\index{GNU software!tar@{\tt tar}}
  version 1.11.2.  This
  is needed to extract the components of the TPIE package from the
  source distribution.
\end{description}

Information on where and how to obtain and install GUN software is
available via FTP from 
\htmladdnormallink{{\tt ftp://prep.ai.mit.edu:/pub/gnu/GNUinfo/FTP}}%
{ftp://prep.ai.mit.edu:/pub/gnu/GNUinfo/FTP}
For a variety of information about GNU software and how it is written
and distributed, 
consult the various other files in the directory
\htmladdnormallink{{\tt ftp://prep.ai.mit.edu:/pub/gnu/GNUinfo/}}%
{ftp://prep.ai.mit.edu:/pub/gnu/GNUinfo/}.

\section{Installation}

\index{installation}
Once you have obtained the TPIE source distribution file
{\tt tpie-\version.tar.gz}, you must decide where to install it.
\verb|/usr/local/tpie/| is a typical place.

Place {\tt tpie-\version.tar.gz} in the directory in which TPIE is to
be installed, \verb|cd| into that directory, and execute the command

\begin{verbatim}
tar czf tpie.tar.gz
\end{verbatim}

This will produce a directory {\tt tpie-\version} with subdirectories
\verb|inc|, \verb|lib|, \verb|test|, and \verb|apps|.  Enter the
directory \verb|tpie|.  You must now configure TPIE for your
particular system.  To do this, use the command

\begin{verbatim}
./configure
\end{verbatim}

\index{configuration}The configuration program will take some time to
examine the parameters of your system.  Once it has done so, it will
produce the various makefiles and configuration files required to
build TPIE on your system.  When this is done, simply type

\begin{verbatim}
make all
\end{verbatim}

to build the complete TPIE system.  This will build the following
components:

\begin{description}
\item[\verb|inc|] The TPIE header files.\index{header files}
\item[\verb|lib|] The TPIE library.  This is relatively small, as most
  of the TPIE system remains in the form of templated header
  files.\index{library}
\item[\verb|test|] A series of test applications designed to verify
  that TPIE is operating correctly.  This directory also includes the
  code to the example applications described in
  Chapter~\ref{ch:examples}.\index{test applications}
\item[\verb|doc|] Complete documentation for TPIE, consisting of the
  document you are reading right now in various formats: HTML for
  viewing with Mosaic and similar programs; and DVI and Postscript(TM)
  for printing.\index{documentation}
\end{description}

Alternatively, individual components can be built one at a time.  For
example, to build only the header files, type 

\begin{verbatim}
make inc
\end{verbatim}

It is possible to customize the installation by providing arguments to
the {\tt configure} script.\index{configuration:options} None of these
arguments are necessary, and the first time you build TPIE, you should
probably not need any of them.  The arguments recognized are as
follows:
\begin{description}
\item[\verb|--enable-log-lib|] 
  \index{enable-log-lib@{\tt --enable-log-lib}}
  Enable logging in TPIE library code.
  This can also be accomplished at compile time by defining the macro
  \verb|TP_LOG_LIB| using the syntax \verb|make lib TP_LOG_LIB=1|.
  This is useful for debugging the TPIE library, but slows it down.
  This option works by defining \verb|TPL_LOGGING|
  \index{TPL_LOGGING@{\tt TPL\_LOGGING}} (see Section~\ref{sec:macros})
  when compiling the library.
\item[\verb|--enable-assert-lib|]  
  \index{enable-assert-lib@{\tt --enable-assert-lib}}
  Enable assertions in the TPIE library code for debugging purposes.
  This can also be accomplished at compile time by defining the macro
  \verb|TP_ASSERT_LIB| using the syntax \verb|make lib TP_LOG_LIB=1|.
  This option works by defining \verb|DEBUG_ASSERTIONS|
  \index{DEBUG_ASSERTIONS@{\tt DEBUG\_ASSERTIONS}} 
  (see Section~\ref{sec:macros})
  when compiling the library.
\item[\verb|--enable-log-apps|] 
\item[\verb|--enable-assert-apps|]  
  \index{enable-assert-apps@{\tt --enable-assert-apps}}
  \index{enable-log-apps@{\tt --enable-log-apps}}
  Similar to {\tt --enable-log-lib} and {\tt --enable-assert-lib}, but
  they apply to the test application code.  Running \verb|make test|
  with the options \verb|TP_LOG_APPS=1| and/or \verb|TP_ASSERT_APPS=1|
  accomplishes the same thing.
\item[\verb|--enable-expand-ami-scan|]  Expand the macros in the file
  \verb|ami_scan.h| when making the include directory with the
command {\tt make inc} (or {\tt make all}).  This is mainly useful for
debugging the code in \verb|ami_scan.h| itself, and is not normally
needed by TPIE programmers.  It may make compilation of TPIE programs
slightly faster because the macro processor of the C++ compiler will
have less work to do.  In addition to the standard GNU tools mentioned
in Section~\ref{sec:gnu-software}, this requires \verb|perl|.
\item[\verb|--disable-*|]  Any of the options above can be explicitly
  disabled  by using this syntax.  For example
  \verb|--disable-expand-ami-scan|. 
\end{description}


\chapter{Tutorial}
\label{ch:tutorial}

\section{Introduction}

This tutorial is designed to introduce new users to the TPIE system.
It introduces the fundamental paradigms of computation that TPIE
supports, giving source code examples of each.  The majority of the
code presented in the tutorial is available in the test
applications\index{test applications} directory of the distribution, 
{\tt tpie-\version/test/}.

For the sake of brevity, much of the code presented in this tutorial
is incomplete, in the sense that necessary header files 
\index{header files} and macros\index{macros} are omitted.  Details 
concerning how to write your own complete TPIE code is presented at
the end of the tutorial in Section~\ref{sec:complete}.

\section{C++}

If you would like the use TPIE but are not familiar with the
C++\index{C++} language, a number of good books are available.  If you
are familiar with C\index{C}, \cite{pohl:c++} is a good place to
start.  A more basic, but very comprehensive book
is~\cite{deitel:c++}.  Once you have mastered the basics,
\cite{meyers:effective} an excellent source of information on
intermediate and advanced C++.  Finally, \cite{ellis:arm} is the
definitive book on C++, though not necessarily the bast place for new
programmers to start.


\section{Streams}

\index{stream}\index{structure!of streams}
Conceptually, TPIE programs work with streams of data stored on
external memory.  A stream is an ordered collection of objects of a
particular type.  Various paradigms of computation are defined on
these streams, though the functional details of the computation
performed within these paradigms is left to the TPIE programmer to
specify.  These details are specified using an operation management
object,\index{operation management object} which is an object with
member functions designed to work with the particular paradigm being
used.  Operation management objects are also known as operation
managers.\index{operation manager|see{operation management object}}.

Creating a stream of objects in TPIE is very much like creating any other
object in C++.  The only difference is that data placed in the stream,
whether explicitly, or as is more commonly the case, implicitly, is
stored on disk.  For example, to create a stream of integers, we could
use either of the following:
\begin{verbatim}
AMI_STREAM<int> stream0;

AMI_STREAM<int> *pstream0 = new AMI_STREAM<int>;
\end{verbatim}

The {\tt AMI} in {\tt AMI\_STREAM} stands for Access Method
Interface\index{access method interface}, which is the level of TPIE
that most applications interact with.  
{\tt AMI\_STREAM} is actually a macro that evaluates to the name of a
particular implementation of streams at the AMI level, but for now it
is safe to assume that it is simply a class.

The {\tt AMI\_STREAM} constructor does not actually put anything into
the stream; it simply creates the necessary data structures to keep
track of the contents of the stream when data is actually put into it.
Data is typically put into streams using \verb|AMI_scan()|, which is
described in the next section.

\section{Scanning}
\label{sec:scanning}

\index{scanning|(} \index{AMI_scan()@{\tt AMI\_scan()}}
The simplest paradigm available in TPIE is scanning.  Scanning can be
used to produce streams, examine the contents of streams, or transform
streams.  

\subsection{Basic Scanning}

The most basic thing a scan can do is write a series of objects to a
stream.  In the following example, we create a stream of integers
consisting of the first 10000 natural numbers.

\begin{verbatim}
class scan_count : AMI_scan_object {
private:
    int maximum;
public:
    int ii;

    scan_count(int max = 1000) : maximum(max), ii(0) {};

    AMI_err initialize(void) 
    {
        ii = 0;
        return AMI_ERROR_NO_ERROR;
    };

    AMI_err operate(int *out1, AMI_SCAN_FLAG *sf)
    {
        *out1 = ++ii;
        return (*sf = (ii <= maximum)) ? AMI_SCAN_CONTINUE : 
            AMI_SCAN_DONE;
    };
};

scan_count sc(10000);
AMI_STREAM<int> amis0;    

void f()
{
    AMI_scan(&sc, &amis0);
}
\end{verbatim}

The class \verb|scan_count| is a class of scan management
object\index{operation management object!scan}.  It has two member
functions, \verb|initialize()| and \verb|operate()|, which TPIE calls
when asked to perform a scan.  The first member function,
\verb|initialize()| is called at the beginning of the scan.  TPIE
expects that a call to this member function will cause the object to
initialize any internal state it may maintain in preparation for
performing a scan.  The second member function, \verb|operate()|, is
called repeatedly during the scan to create objects to go into the
output stream.  \verb|operate()| sets the flag \verb|*sf| to indicate
whether it generated output or not.  Only when \verb|operate()|
returns either an error or \verb|AMI_SCAN_DONE| does TPIE stop calling
it.

The call to \verb|AMI_scan| behaves as the following pseudo-code:

\begin{verbatim} 
AMI_err AMI_scan(scan_count &sc, AMI_STREAM<int> *pamis)
{
    int ii;
    AMI_err ae;    
    AMI_SCAN_FLAG sf;

    sc.initialize();    
    while ((ae = sc.operate(&ii, &sf)) == AMI_SCAN_CONTINUE) {
        if (sf) {
            write ii to *pamis;
        }
    }

    if (ae != AMI_SCAN_DONE) {
        handle error conditions;
    }

    return AMI_ERROR_NO_ERROR;
}
\end{verbatim}

Thus, after the function \verb|f()| in the original example code is
called, the stream \verb|amis0| contains the integers from 1 to 10000
in order.

Now that we have produced a stream, there are a variety of things we
can do with it.  One of the simplest things we can do with a stream of
objects is scan it in order to transform it in some way.  As an
example, suppose we wanted to square every integer in the stream
\verb|amis0|.  We could do so using the following code:

\begin{verbatim}
class scan_square : AMI_scan_object {
public:
    AMI_err initialize(void)
    {
        return AMI_ERROR_NO_ERROR;
    };

    AMI_err operate(const int &in, AMI_SCAN_FLAG *sfin,
                    int *out, AMI_SCAN_FLAG *sfout)
    {
        if (*sfout = *sfin) {
            *out = in * in;
            return AMI_SCAN_CONTINUE;
        } else {
            return AMI_SCAN_DONE;
        }
    };
};

scan_square ss;
AMI_STREAM<int> amis1;    

void g() 
{
    AMI_scan(&amis0, &ss, &amis1);
}
\end{verbatim}

Notice that the call to \verb|AMI_scan()| in \verb|g()| differs from
the one we used in \verb|f()| in that it takes two stream pointers and
a scan management object.  By convention, the stream \verb|amis0| is
an input stream, because it appears before the scan management object
\verb|ss| in the argument list.  By similar convention, \verb|amis1|
is an output stream.  Because the call to \verb|AMI_scan| has one
input stream and one output stream, TPIE expects the \verb|operate()|
member function of \verb|ss| to have one input argument (which is
called \verb|in| in the example above) and one output argument (called
\verb|out| in the example above).  Note that the \verb|operate()|
member function of the class \verb|square_scan| also takes two
pointers to flags, one for input (\verb|sfin|) and one for output
(\verb|sfout|).  \verb|*sfin| is set by TPIE to indicate that there is
more input to be processed.  \verb|*sfout| is set by the scan
management object to indicate when output is generated.
If a scan management object has no polymorph of \verb|operate()| that
takes the appropriate type number of arguments for the invocation of
\verb|AMI_scan()| that uses it then a compile-time error is generated.

A call to \verb|AMI_scan| with one input stream and one output stream
behaves as the following pseudo-code:

\begin{verbatim} 
AMI_err AMI_scan(AMI_STREAM<int> *instream, scan_square &ss, 
        AMI_STREAM<int> *outstream)
{
    int in, out;
    AMI_err ae;    
    AMI_SCAN_FLAG sfin, sfout;

    sc.initialize();

    while (1) {
        {
             read in from *instream;
             sfin = (read succeeded);
        }
        if ((ae = ss.operate(in, &sfin, &out, &sf)) == 
            AMI_SCAN_CONTINUE) {
            if (sfout) {
                write out to *outstream;
            }
            if (ae == AMI_SCAN_DONE) {
                return AMI_ERROR_NO_ERROR;
            }
            if (ae != AMI_SCAN_CONTINUE) {
                handle error conditions;
            }
        }
    }
}
\end{verbatim}

More complicated invocations of \verb|AMI_scan()| can operate on up
to four input streams and four output streams.  Here is an example
that takes two input streams of values, \verb|x| and \verb|y|, and
produces four output streams, 
one consisting of the running sum of the
\verb|x| values,
one consisting of the running sum of the
\verb|y| values,
one consisting of the running sum of the
squares of the \verb|x| values,
and
one consisting of the running sum of the
squares of the \verb|y| values.

\begin{verbatim}
class scan_sum : AMI_scan_object {
private:
    double sumx, sumx2, sumy, sumy2;
public:
    AMI_err initialize(void)
    {
        sumx = sumy = sumx2 = sumy2 = 0.0;
        return AMI_ERROR_NO_ERROR;
    };

    AMI_err operate(const double &x, const double &y, 
                    AMI_SCAN_FLAG *sfin,
                    double *sx, double *sy, 
                    double *sx2, double *sy2, 
                    AMI_SCAN_FLAG *sfout)
    {
        if (sfout[0] = sfout[2] = sfin[0]) {
            *sx = (sumx += x);
            *sx2 = (sumx2 += x * x);
        }
        if (sfout[1] = sfout[3] = sfin[1]) {
            *sy = (sumx += y);
            *sy2 = (sumy2 += y * y);
        }        
        return (sfin[0] || sfin[1]) ? AMI_SCAN_CONTINUE : AMI_SCAN_DONE;
    };
};

AMI_STREAM<double> xstream, ystream;

AMI_STREAM<double> sum_xstream, sum_ystream, sum_x2stream, sum_y2stream;

scan_sum ss;

void h()
{
    AMI_scan(&xstream, &ystream, &ss, 
             &sum_xstream, &sum_ystream, &sum_x2stream, &sum_y2stream);
}
\end{verbatim}

\subsection{ASCII Input/Output} \label{sec:ascii-io}

\index{ASCII I/O|see{scanning, ASCII I/O}}
\index{scanning!ASCII I/O|(}
TPIE provides a number of predefined scan management objects.  Among
the most useful are instances of the template classes
\verb|cxx_ostream_scan<T>| and \verb|cxx_ostream_scan<T>|, which are
used for reading ASCII data into streams and writing the contents of
streams in ASCII respectively.  This is done in conjunction with the
\verb|iostream| facilities provided in the standard C++ library.  Any
class \verb|T| for which the operators \verb|ostream
&operator<<(ostream &s, T &t)| and \verb|istream &operator>>(T &t)|
are defined can be used with this mechanism.

As an example, suppose we have a file called \verb|input_nums.txt|
containing one integer per line, such as

\begin{verbatim}
17
289
4195835
3145727
.
.
.
\end{verbatim}

To read this file into a TPIE stream of integers, square each, and
write them out to the file \verb|output_nums.txt| we could use the
following code:

\begin{verbatim}
void f()
{
    ifstream in_ascii("input_nums.txt");
    ofstream out_ascii("input_nums.txt");
    cxx_istream_scan<int> in_scan(in_ascii);
    cxx_ostream_scan<int> out_scan(out_ascii);
    AMI_STREAM<int> in_ami, out_ami;
    scan_square ss;    

    // Read them.
    AMI_scan(&in_scan, &in_ami);

    // Square them.
    AMI_scan(&in_ami, &ss, &out_scan);
    
    // Write them.
    AMI_scan(&out_ami, out_scan);

}    
\end{verbatim}

In order to read from an input file using the scan object
\verb|in_scan|, \verb|AMI_scan()| repeatedly calls
\verb|in_scan->operate()|, just as it would for any scan object.  Each
time \verb|in_scan->operate()| is called, it uses the \verb|>>|
operator to read a single integer from the input file.  When the input
file is exhausted, \verb|in_scan->operate()| returns
\verb|AMI_SCAN_DONE|, and \verb|AMI_scan()| returns to its caller.
The behaviour of \verb|out_scan| is similar to that of \verb|in_scan|,
except that it writes to a file instead of reading from one.
\index{scanning!ASCII I/O|)}

\subsection{Multi-Type Scanning}

\index{scanning!multi-type|(}

In all of the examples presented up to this point, scanning has been
done on streams of objects that are all of the same type.
\verb|AMI_scan()| is not limited to such scans, however.  In the
following example, we have a scan management class that takes two
streams of \verb|double|s and returns a stream of complex numbers.

\begin{verbatim}
class complex {
public:
    complex(double real_part, imaginary_part);
    ...
};

class scan_build_complex : AMI_scan_object {
public:
    AMI_err initialize(void) {};
    AMI_err operate(const double &r, const double &i, 
                    AMI_SCAN_FLAG *sfin,
                    complex *out, AMI_SCAN_FLAG *sfout)
    {
        if (*sfout = (sfin[0] || sfin[1])) {
            *out = complex((sfin[0] ? r : 0.0), (sfin[1] ? i : 0.0));
            return AMI_SCAN_CONTINUE;
        } else {
            return AMI_SCAN_DONE;
        }   
    };
};
\end{verbatim}
\index{scanning!multi-type|)}

\subsection{Out of Step Scanning}
\label{sec:out-of-step}

\index{scanning!out of step|(}
In all the examples up to this point, every call to the
\verb|operate()| member function of a scan management object has been
called with each object in the input stream(s) exactly once.  In this
section, we introduce the concept of out of step scanning, which
allows a scan management object to reject certain inputs and ask that
they be resubmitted in subsequent calls to the \verb|operate()| member
function.

Suppose we have two streams of integers, each of which we know is
sorted in ascending order.  We would like to merge the two streams
into a single output stream consisting of all the integers in the two
input streams, in sorted order.  In order to do this with a scan, we
must have the ability to look at the next integer from each stream,
choose the smaller of the two and write it to the output stream, and
then ask for the next number from the stream from which it was taken.
Luckily, there is a simple mechanism for doing this.  The same flags
that TPIE uses to tell the scan management object which inputs are
available can be used by the scan management object to indicate which
inputs were used and which should be presented again.

Consider the following example of a scan management object class which
performs exactly the sort of binary
merge\index{merge!binary}\index{merge sort!binary} described in the
preceding paragraph:

\begin{verbatim}
class scan_binary_merge : AMI_scan_object {
public:
    AMI_err initialize(void) {};
    
    AMI_err operate(const int &in0, const int &in1, AMI_SCAN_FLAG *sfin,
                    int *out, AMI_SCAN_FLAG *sfout) 
    {
        if (sfin[0] && sfin[1]) {
            if (in0 < in1) {
                sfin[1] = false;
                *out = in0;
            } else {
                sfin[0] = 0;
                *out = in1;
            }
        } else if (!sfin[0]) {
            if (!sfin[1]) {
                *sfout = 0;
                return AMI_SCAN_DONE;
            } else {
                *out = in1;
            }
        } else {
            *out = in0;
        }
        *sfout = 1;
        return AMI_SCAN_CONTINUE;
    }    
};
\end{verbatim}

In the operate method, we first check that both inputs are valid by
looking at the flags pointed to by \verb|sfin|.  If both are valid,
then we select the smaller of the inputs and copy it to the output.
We then clear the other input flag to let TPIE know that we did not
use that input, but we will need it later and it should be resubmitted
on the next call to operate.  The remainder of the function handles
the cases when one of more of the input streams in empty.
\index{scanning!out of step|)}
\index{scanning|)}

\section{Merging} \label{sec:merging}
\index{merging|(}

The binary merging scan management class presented in the previous
section could be used recursively to implement a merge
sorting\index{merge sorting!binary} algorithm.  We could simply divide
the input stream into sub-streams small enough to fit into main
memory, read each sub-stream into memory and sort it, and then merge
pairs of streams, then pairs of merged pairs of streams, and so on,
until we had merged all the input back into one completely sorted
stream.  While this approach would correctly sort the input, it would
not be nearly as efficient as possible on most machines.  The reason
is that we typically have enough main memory available to merge many
streams together at one time.

Taking advantage of all available main memory can be difficult, since
we must explicitly keep track to the space needed for input blocks
form each of the streams being merged, as well as the overhead of any
data structures needed for the merge.  Luckily, TPIE provides a
mechanism that does most of the work for us.  The function
\verb|AMI_partition_and_merge()| divides an input stream into
sub-streams just small enough to fit into main memory, operates on
each in main memory, then merges them back into a single output
stream, using intermediate streams if memory constraints dictate.  As
was the case with \verb|AMI_scan()|, the functional details of
\verb|AMI_partition_and_merge()| are specified via an operation
management object,\index{operation management object} as shown in the
following example:

\begin{verbatim}
class my_merger : AMI_merge_manager {
public:
    AMI_err initialize(arity_t arity, const T * const *in,
                       AMI_merge_flag *taken_flags,
                       int &taken_index);
    AMI_err operate(const T * const *in, AMI_merge_flag *taken_flags,
                    int &taken_index, T *out);
    AMI_err main_mem_operate(T* mm_stream, size_t len);
    size_t space_usage_overhead(void);
    size_t space_usage_per_stream(void);
};

AMI_STREAM<T> instream, outstream;

void f() 
{
    my_merger mm;    
    AMI_partition_and_merge(&instream, &outstream, &mm);
}
\end{verbatim}

The class members are as follows:

\begin{description}
\item[\verb|initialize()|] Tells the object how many streams it should
  merge (\verb|arity|) and what the first item from each stream is
  (\verb|in|).  \verb|taken_flags| and \verb|taken_index| provide two
  mechanisms for the merge manager to tell TPIE what objects it took
  from the input streams.  These are discussed in more detail in 
  the context of a merge sorting example in Section~\ref{sec:mergesort}.
\item[\verb|operate()|]
Just as in scanning, this member function is called repeatedly to process input objects.
\item[\verb|main\_mem\_operate()|]
Operates on an array of data in main memory when a sub-stream is small enough to fit entirely in main memory.
\item[\verb|space\_usage\_overhead()|]
Called by TPIE prior to initialization to asses how much main memory this object will use.
\item[\verb|space\_usage\_per\_item()|]
Called by TPIE prior to initialization to asses how much main memory may be used per input stream.  Merge management objects are allowed to use main memory space linear in the number of input streams.
\end{description}

\verb|AMI_partition_and_merge()| behaves as indicated by the following
pseudo-code.  Note that for simplicity of presentation, boundary
conditions are not covered.

\begin{verbatim}
AMI_err AMI_partition_and_merge(instream, outstream, mm)
{
    max_ss = max # of items that can fit in main memory;
    partition instream into num_substreams substreams of size max_ss;

    foreach substream[i] {
        read substream[i] into main memory;
        mm->main_mem_operate(substream[i]);
        write substream[i];
    }

    call mm->space_usage_overhead() and mm->space_usage_per_stream;
    
    compute merge_arity; // Maximum # of streams we can merge.     

    while (num_substreams > 1) {
        for (i = 0; i < num_substreams; i += merge_arity) {
            merge substream[i] .. substream[i+merge_arity-1];
        }
        num_substreams /= merge_arity;
        max_ss *= merge_arity;
    }

    write single remaining substream to outstream;
        
    return AMI_ERROR_NO_ERROR;
}
\end{verbatim}

\subsection{Implementing Mergesort: An Extended Example}
\label{sec:mergesort}

Here is an example of the implementation and use of a merge management
object for merge sorting integers.  First, we declare the class:

\begin{verbatim}
class s_merge_manager : public AMI_merge_base<int> {
private:
    arity_t input_arity;
    pqueue *pq;
public:
    s_merge_manager(void);
    virtual ~s_merge_manager(void);
    AMI_err initialize(arity_t arity, const int * const *in,
                       AMI_merge_flag *taken_flags,
                       int &taken_index);
    AMI_err operate(const int * const *in, AMI_merge_flag *taken_flags,
                    int &taken_index, int *out);
    AMI_err main_mem_operate(int* mm_stream, size_t len);
    size_t space_usage_overhead(void);
    size_t space_usage_per_stream(void);
};
\end{verbatim}

In addition to the standard class members for a merge management
object, we have the following:

\begin{description}
\item[\verb|input\_arity|]
The number of input streams the merge management object must handle.
\item[\verb|pq|]
A priority queue into which items will be placed.
\item[\verb|s\_merge\_manger()|]
A constructor.
\item[\verb|~s\_merge\_manger()|]
A destructor.
\end{description}

Construction and destruction are fairly straightforward.  At
construction time, we have no priority queue because we do not yet
know how big the priority queue should be.  \verb|pq| will be set up
when \verb|initialize| is called.  The destructor checks whether
\verb|pq| is valid, and deletes it if it is.  The constructor and
destructor are implemented as follows:

\begin{verbatim}
s_merge_manager::s_merge_manager(void)
{
    pq = NULL;
}

s_merge_manager::~s_merge_manager(void)
{
    if (pq != NULL) {
        delete pq;
    }
}
\end{verbatim}

When \verb|AMI_merge()| is called with a merge management object of
type \verb|s_merge_manager|, the first member functions called are
\verb|space_usage_overhead()| and \verb|space_usage_per_stream()|.
These return the number of bytes of main memory that the merge
management object will allocate when initialized.  
\verb|space_usage_overhead()|'s return value indicates that space will
be needed for a priority
queue.  
\verb|space_usage_per_stream()|'s return value indicates that for each
input stream, space (which is to be allocated when the priority
queue is constructed) will be needed for an integer and an arity type.

\begin{verbatim}
size_t s_merge_manager::space_usage_overhead(void)
{
    return sizeof(pqueue<arity_t,int>);
}


size_t s_merge_manager::space_usage_per_stream(void)
{
    return sizeof(arity_t) + sizeof(int);
}
\end{verbatim}

The next member function called by \verb|AMI_merge()| is
\verb|main_mem_operate()|, which is called to handle the initial
substreams that are small enough to fit in main
memory.  Since we are sorting, we will simply use
quicksort.

\begin{verbatim}
AMI_err s_merge_manager::main_mem_operate(int* mm_stream, size_t len)
{
    qsort(mm_stream, len, sizeof(int), c_int_cmp);
    return AMI_ERROR_NO_ERROR;
}
\end{verbatim}

Having sorted all of the initial substreams, \verb|AMI_merge()| begins
to merge them.  Before merging a set of substreams, the merge
management object's member function \verb|initialize()| is called to
inform the merge management object of the number of streams it should
be prepared to merge.  The object is also provided with the first
object from each of the streams to be merged.  For objects of the
class \verb|s_merge_manager|, the \verb|initialize()| member function
is as follows:

\begin{verbatim}
AMI_err s_merge_manager::initialize(arity_t arity, CONST int * CONST *in,
                                          AMI_merge_flag *taken_flags,
                                          int &taken_index)
{
    arity_t ii;

    input_arity = arity;

    if (pq != NULL) {
        delete pq;
    }

    // Construct a priority queue that can hold arity items.
    pq = new pqueue_heap_op(arity);

    for (ii = arity; ii--; ) {
        if (in[ii] != NULL) {
            taken_flags[ii] = 1;
            pq->insert(ii,*in[ii]);
        } else {
            taken_flags[ii] = 0;
        }
    }

    taken_index = -1;
    return AMI_MERGE_READ_MULTIPLE;
}
\end{verbatim}

Note the use of the return value \verb|AMI_MERGE_READ_MULTIPLE|.  This
indicates that the flags pointed to by \verb|*taken_flags| are set to
indicate which of the inputs were used and should not be presented
again.  This is very similar to the use of input flags to indicate
which inputs were used by a scan management object as described in
Section~\ref{sec:out-of-step}.  The reason that we have a special
return value to indicate when these flags are used to increase
performance.  In order for \verb|AMI_scan()| to determine which inputs
were taken, it must examine all the flags.  In a many way merge, this
might be time consuming.  In cases where only one item is taken, its
index can be returned in \verb|taken_index| in order to save the time
that would be spent scanning the flags.  This technique is used in the
\verb|operate()| member function, whose implementation is as follows:

\begin{verbatim}
AMI_err s_merge_manager::operate(CONST int * CONST *in,
                                       AMI_merge_flag *taken_flags,
                                       int &taken_index,
                                       int *out)
{
    // If the queue is empty, we are done.  There should be no more
    // inputs.
    if (!pq->num_elts()) {
        return AMI_MERGE_DONE;
    } else {
        arity_t min_source;
        int min_t;

        pq->extract_min(min_source,min_t);
        *out = min_t;
        if (in[min_source] != NULL) {
            pq->insert(min_source,*in[min_source]);
            taken_index = min_source;
        } else {
            taken_index = -1;
        }
        return AMI_MERGE_OUTPUT;
    }
}
\end{verbatim}
\index{merging|)}

\section{Distribution} \label{sec:distribution}

Distribution has not been implemented in the current version of TPIE.
It is primarily useful for parallel disks, and will be implemented in
the parallel disk version of TPIE.  On a single disk, merging should
be adequate for all applications where distribution might be
considered.

On a single disk, distribution will tend to result in algorithms that
take roughly twice as long as similar algorithms that use merging.
This is because distribution is done to the square root of the number
of streams that can be buffered in main memory rather than the full
number.  This results in recursion that is twice as deep.

\section{Permutation}

\subsection{General Permutation}

Permutation is a basic building block for many I/O algorithms.
Routing a general permutation in the I/O model is asymptotically as
complex as sorting, though for some important classes of permutations,
such as BMMC permutations (See Section~\ref{sec:bit-permuting}) faster
algorithms are possible.  In this section, we discuss
\verb|AMI_general_permute()|, which routes arbitrary permutations, but
always takes as long as sorting, regardless of whether the particular
permutation can be done more quickly or not.

General permutations are routed using the function
\verb|AMI_general_permute()|.  Like other AMI functions,
\verb|AMI_general_permute()| relies on an operation management
object\index{operation management object} to determine its precise
behavior.  Unlike functions covered up to now, however, the type of
the operation management object\index{operation management object}
need not depend on the type of object in the stream being permuted.

A general permutation management object must provide two member
functions, \verb|initialize()| and \verb|destination|.
\verb|initialize()| is called to inform the general permutation object
of the length of the stream to be permuted.  \verb|destination()| is
then called repeatedly to determine the destination for each object in
the stream based on it's initial position.

Here is an example of using general permutation to reverse the order
of the items in a stream.

\begin{verbatim}
class reverse_order : public AMI_gen_perm_object {
private:
    off_t total_size;
public:
    AMI_error initialize(off_t ts) { 
        total_size = ts; 
        return AMI_ERROR_NO_ERROR;
    };
    off_t destination(off_t source) {
        return total_size - 1 - source;
    };
};

AMI_STREAM<int> amis0, amis1;    

void f()
{
    reverse_order ro;

    AMI_general_permute(&amis0, &amis1, (AMI_gen_perm_object *)&ro);
}
\end{verbatim}

\subsection{Bit Permutation}
\label{sec:bit-permuting}

Bit permuting is a permutation technique in which the destination
address of a given item is computed by manipulating the bits of its
source address.  The particular class of bit permutations that TPIE
supports is the set of bit matrix multiply complement (BMMC)
permutations.  These permutations are defined on sets of objects whose
size is a power of 2.

Suppose we have an input consisting of $N = 2^n$ objects.  A BMMC
permutation on the input is defined by a nonsingular $n @times n$ bit
matrix $A$ and an $n$ element column vector $c$ of bits.  Source and
destination addresses are interpreted as column vectors of bits, with
the low order bit of the address at the top.  The destination address
$x'$ corresponding to a given source address $x$ is computed as
$$x' = Ax + c$$ where addition and multiplication of matrix elements
is done over GF(2).  For a detailed description of BMMC permutations,
see~\cite{cormen:integrate-tr}.
%\htmladdnormallink{Dartmouth College Technical Report PCS-TR94-223}%
%{ftp://cs.dartmouth.edu:/pub/CS-techreports/TR94-223.ps.Z}.

Routing BMMC permutations in TPIE is done using the
\verb|AMI_BMMC_permute()| entry point, which takes an input stream,
and output stream, and a pointer to a bit permutation management
object.  In the following example, we route a permutation that simply
reverses the order of the source address bits to produce the
destination address.

First, we construct the matrices the permutation will use.
\index{bit_matrix@{\tt bit\_matrix}}
\begin{verbatim}
    bit_matrix A(n,n);
    bit_matrix c(n,1);

    {
        unsigned int ii,jj;

        for (ii = n; ii--; ) {
            c[ii][0] = 0;
            for (jj = n; jj--; ) {
                A[n-1-ii][jj] = (ii == jj);
            }
        }
    }
\end{verbatim}
Now we simply construct a permutation management object from the
matrices and perform the permutation.
\begin{verbatim}
    AMI_bit_perm_object bpo(A,c);
    
    ae = AMI_BMMC_permute(&amis0, &amis1, (AMI_bit_perm_object *)&bpo);
\end{verbatim}


\section{Sorting}

\subsection{Comparison Sorting} \label{sec:cmp-sorting}

\index{sorting!comparison|(}
Sorting is a common primitive operation in many algorithms.  It can be
performed in a variety of ways, such as by merging (See
Section~\ref{sec:merging}), distribution (See
Section~\ref{sec:distribution}), Sharesort~\cite{aggarwal:optimal},
which combines elements of both along with simple bit permutations
(See Section~\ref{sec:bit-permuting}).  Because the best choice of
sorting algorithm varies from one I/O system to the next, TPIE
provides a single function \verb|AMI_sort()|, which selects an
appropriate algorithm based on the underlying hardware
characteristics.

\verb|AMI_sort()| has two polymorphs.  The first works on streams of
objects for which the operator \verb|<| is defined.  It is invoked as
follows:

\begin{verbatim}
AMI_STREAM<int> instream;
AMI_STREAM<int> outstream;

void f()
{
    AMI_sort(&instream, &outstream);
}
\end{verbatim}

The second polymorph of \verb|AMI_sort()| uses an explicit function to
determine the relative order of two objects in the input stream.  This
is useful in cases where we may want to sort a stream of objects in
several different ways.  For example, the following code sorts a
stream of complex numbers in two ways, by their real parts and by
their imaginary parts.

\begin{verbatim}
class complex {
public:
    complex(double real_part, imaginary_part);
    double re(void);
    double im(void);
    ...
};

int compare_re(const complex &c1, const complex &c2)
{
    return (c1.re() < c2.re()) ? -1 :
           ((c1.re() > c2.re()) ? 1 : 0);
}

int compare_im(const complex &c1, const complex &c2)
{
    return (c1.im() < c2.im()) ? -1 :
           ((c1.im() > c2.im()) ? 1 : 0);
}

AMI_STREAM<complex> instream;
AMI_STREAM<complex> outstream_re;
AMI_STREAM<complex> outstream_im;

void f()
{
    AMI_sort(&instream, &outstream_re, compare_re);
    AMI_sort(&instream, &outstream_im, compare_im);
}
\end{verbatim}

\index{sorting!comparison|)}

\subsection{Key Bucket Sorting}
\label{sec:kb-sorting}

\index{sorting!key bucket|(}
\index{sorting!key bucket|)}

\section{Matrix Operations}
\label{sec:matrix}

\index{matrices|(}

In addition to streams, which are linearly ordered collections of
objects, the AMI provides a mechanism for storing large matrices in
external memory.  Matrices are a subclass of streams, and thus can be
used with any of the stream operations discussed above.  When a matrix
is treated as a stream its elements appear in row major order.  In
addition to stream operations, matrices support three simple
arithmetic operations, addition, subtraction, and multiplication.

It is assumed that the class \verb|T| of the elements in a matrix
forms a quasiring with the operators \verb|+| and \verb|*|.
Furthermore, the object \verb|T((int)0)| is assumed to be an identity
for \verb|+|.  At the moment, it is not assumed that the operator
\verb|-| in an inverse of \verb|+|, and therefore no reduced
complexity matrix multiplication algorithms analogous to Strassen's
algorithm are used.

There are two different classes of matrices that TPIE provides, dense,
and sparse.

\subsection{Dense Matrix Operations}
\label{sec:dense-mat}

\index{matrices!dense|(}

Dense matrices are implemented by the templated class
\verb|AMI_matrix|,\index{AMI_matrix@{\tt AMI\_matrix}}
 which is a subclass of
\verb|AMI_STREAM|.\index{AMI_STREAM@{\tt AMI\_STREAM}}

Dense matrices can be filled using \verb|AMI_scan()|, though typically
they are filled using the function \verb|AMI_matrix_fill()|, which
uses a scan management object that is given the row and column of each
element of the matrix and asked to fill them in.  In the following
example, we create a 1000 by 1000 upper triangular matrix of ones and
zeroes:

\begin{verbatim}
template<class T>
class fill_upper_tri : public AMI_matrix_filler<T> {
    AMI_err initialize(unsigned int rows, unsigned int cols)
    {
        return AMI_ERROR_NO_ERROR;
    };
    T element(unsigned int row, unsigned int col)
    {
        return (row <= col) ? T(1) : T(0);
    };
};

AMI_matrix m(1000, 1000);

void f()
{
    fill_upper_tri<double> fut;

    AMI_matrix_fill(&em, (AMI_matrix_filler<T> *)&fut);
}
\end{verbatim}

Arithmetic on dense matrices is performed in a straightforward way
using the functions \verb|AMI_matrix_add()|,
\verb|AMI_matrix_subtract()|, and \verb|AMI_matrix_multiply()|, as is
the following example:

\begin{verbatim}
AMI_matrix m0(1000, 500), m1(500, 2000), m2(1000, 2000);
AMI_matrix m3(1000, 500), m4(1000, 500);

void f()
{
    // Add m3 to m4 and put the result in m0.
    AMI_matrix_add(em3, em4, em0);
   
    // Multiply m0 by em1 to get m2.
    AMI_matrix_mult(em0, em1, em2);

    // Subtract m4 from m3 and put the result in m0.
    AMI_matrix_subtract(em3, em4, em0);        
}
\end{verbatim}

\index{matrices!dense|)}

\subsection{Sparse Matrices}
\label{sec:sparse-mat}

\index{matrices!sparse|(}
\index{matrices!sparse|)}

\subsection{Elementwise Arithmetic}
\label{sec:elementwise}

\index{arithmetic!elementwise|see{elementwise arithmetic}}
\index{elementwise arithmetic|(} 
The functions \verb|AMI_matrix_add()|
and \verb|AMI_matrix_subtract()| defined in
Section~\ref{sec:dense-mat} perform elementwise arithmetic on
matrices.  At times, we might also wish to perform elementwise
multiplication or division, or perform a scalar arithmetic operation
on all elements of a matrix.  TPIE provides mechanisms for doing this
not only on matrices, but on arbitrary streams, so long as they are of
objects for which the appropriate arithmetic operators (i.e. {\tt +},
{\tt -}, {\tt *}, {\tt /}) are defined.

Elementwise arithmetic is done with scan management objects
\index{operation management objects!scan} of the classes
\verb|AMI_scan_add|, \verb|AMI_scan_sub|, \verb|AMI_scan_mult| and
\verb|AMI_scan_div|, which are defined in the header file
\verb|AMI_stream_arith.h|.  Here is an example that performs
elementwise division on the elements of two streams.

\begin{verbatim}
#include <ami_stream_arith.h>

void foo()
{
    AMI_STREAM<int> amis0;
    AMI_STREAM<int> amis1;
    AMI_STREAM<int> amis2;

    // Divide each element of amis0 by the corresponding element of
    // amis1 and put the result in amis2.
    AMI_scan(&amis0, &amis1, &sd, &amis2);
}
\end{verbatim}
\index{elementwise arithmetic|)}

\index{matrices|)}

\section{Writing and Executing Complete TPIE Programs}
\label{sec:complete}
\index{complete TPIE programs}

The fragments of code presented in this tutorial are valuable for
instructive purposes; however, they are incomplete.  In order to
successfully compile, link, and run TPIE applications, some additional
code and appropriate compilation and run-time environments are needed.
These are discussed below.  The best way for a novice TPIE programmer
to begin is probably to look directly at the source code provided in
the {\tt test} directory.  It incorporates all of the necessary
components discussed below.

\subsection{Macros and Header Files}
\label{sec:macros}
\index{macros|(}

The exact behavior or TPIE at run time is controlled be several macros
that can be defined before including any TPIE headers.  In the test
application code\index{test applications} distributed with TPIE, these
are set in the header file {\tt
  tpie-\version/test/app\_config.h}.\index{app_config@{\tt app\_config.h}}
The macros are as follows:
\begin{description}
\item[{\verb|TPL\_LOGGING|}] \index{TPL_LOGGING@{\tt TPL\_LOGGING}} Set
  to a non-zero value to enable logging of TPIE's internal behavior.
  By default, information is logged to the log file\index{log file}
  \verb|/usr/tmp/TPL_XXXXX| where \verb|XXXXX| is a unique system
  dependent identifier.  Typically it encodes the process ID of the
  TPIE process that produced it in some way.  See
  Section~\ref{sec:logging} of the reference manual for information on
  exactly what TPIE writes to the log file.
\item[{\verb|DEBUG\_ASSERTIONS|}] 
  \index{DEBUG_ASSERTIONS@{\tt DEBUG\_ASSERTIONS}}
  \index{debugging!TPIE}
  Set to a non-zero value to enable
  TPIE assertions.  These assertions check for inconsistent or
  erroneous conditions within TPIE itself.  They are primarily
  intended to aid in the debugging of TPIE.  Some overhead is added to
  programs compiled with this macro set.
\item[{\verb|DEBUG\_CERR|}] \index{DEBUG_CERR@{\tt DEBUG\_CERR}}
  \index{debugging!TPIE} Setting this macro to a non-zero value tells
  TPIE to write all internal debugging messages to the C++ standard
  error stream \verb|cerr| in addition to the TPIE log file.
\item[{\verb|DEBUG\_STR|}] 
  \index{DEBUG_STR@{\tt DEBUG\_STR}} \index{debugging!TPIE}
  Setting this macro to a non-zero value enables certain debugging
  messages that report on the internal behavior of TPIE but do not
  necessarily indicate error conditions.  In some cases this can
  increase the size of the log dramatically.
\item[{\verb|AMI\_VIRTUAL\_BASE|}] 
  \index{AMI_VIRTUAL_BASE@{\tt AMI\_VIRTUAL\_BASE}}
  \index{virtual base class!AMI} Setting this macro to a non-zero
  value makes the base class declares a large number of virtual
  functions for the class \verb|AMI_base_stream|, which is the base
  class of all implementations of AMI streams.  This is useful for
  debugging new AMI stream implementations, but many compilers cannot
  properly inline virtual functions, so it slows the system down
  significantly.  Normally, TPIE applications programmers would never
  set this flag.
\item[{\verb|BTE\_VIRTUAL\_BASE|}] 
  \index{BTE_VIRTUAL_BASE@{\tt BTE\_VIRTUAL\_BASE}}
  \index{virtual base class!BTE}  Similar to
  \verb|AMI_VIRTUAL_BASE|, but for the BTE layer.
  Normally, TPIE applications programmers would never
  set this flag.
\item[{\verb|BTE\_IMP\_*|}]
  \index{BTE_IMP_*@{\tt BTE\_IMP\_*}}
  \index{block transfer engine!implementation}
  \index{implementation!BTE}
  A macro of this form is used to tell TPIE which of the available
  block transfer engine implementations to use.  Version \version of
  TPIE is distributed with two implementations.  An implementation
  based on the UNIX {\tt stdio} library
  \index{stdio (UNIX library)@{\tt stdio} (UNIX library)} is selected
  by setting {\tt BTE\_IMP\_STDIO}.  
  \index{implementation!BTE!{\tt stdio} library}
  An implementation based on memory
  mapped I/O\index{memory mapped I/O} is selected by setting 
  {\tt BTE\_IMP\_MMB}.
  \index{implementation!BTE!memory mapped I/O}
\item[{\verb|AMI\_IMP\_*|}]
  \index{AMI_IMP_*@{\tt AMI\_IMP\_*}}
  \index{access method interface!implementation}
  \index{implementation!AMI}
  A macro of this form is used to tell TPIE which of the available
  access method interface implementations to use.  Version \version of
  TPIE is distributed only one AMI implementation, which stores the
  contents of a given stream on a single disk.  This implementation is
  selected by setting 
  {\tt AMI\_IMP\_SINGLE}.
  \index{implementation!AMI!single disk}
\item[{\verb|BTE\_MMB\_READ\_AHEAD|}]
  \index{BTE_MMB_READ_AHEAD@{\tt BTE\_MMB\_READ\_AHEAD}}
  \index{read ahead}
  When the memory mapped I/O implementation of the BTE layer is
  selected, setting this flag tells the BTE to optimize for sequential
  read speed by reading blocks into main memory before the
  data they contain is actually needed.  This feature requires the
  asynchronous I/O library {\tt libaio}.\index{libaio library@{\tt
      libaio} library.}
\end{description}
\index{macros|)}

\index{header files|(}
One the appropriate macros have been set, TPIE's templated classes and
functions are included by including the header file {\tt ami.h} from
the {\tt include} directory.  Normally, this directory is pointed to
by a {\tt -I} argument to the compiler.  This and other compiler flags
are discussed in more detail in Section~\ref{sec:comp-flags} and are
illustrated by their use un the {\tt Makefile} in the
{\tt test} directory.
\index{header files|)}
 
\subsection{Template Instantiation}

{\bf Important Note:} Much of the information in this section is
likely to change as the template instantiation mechanism of the 
{\tt g++}\index{g++@{\tt g++}} compiler improves.  If you are
interested in the nitty gritty details of template instantiation,
consult~\cite{ellis:arm} or one of the frequent discussions on the
topic in the newsgroup {\tt comp.lang.c++}
\index{comp.lang.c++@{\tt comp.lang.c++}}.

\index{templates!instantiation|(}
\noindent Most of the classes and functions TPIE defines are
templated.  Furthermore, many user written operation management
object\index{operation management objects!user supplied} classes are
likely to be templated; many of those supplied with the test and
sample applications are.

Unfortunately, many C++\index{C++} compilers do not properly implement
templated function and/or classes.  In particular, the GNU C++
compiler, {\tt g++}\index{g++@{\tt g++}}, version \gxxversion, which
was used in the development of TPIE has some deficiencies when it
comes to template instantiation.  It also has a well defined mechanism
for working around these deficiencies, which TPIE takes significant
advantage of.  This mechanism prevents the compiler from implicitly
instantiating any template.  Thus, all templates used by a program
must be explicitly instantiated at compile time or they will not be
available at link time and linking will fail.

In order to tell {\tt g++}\index{g++@{\tt g++}} not to implicitly
instantiate any templates, the {\tt -fno-implicit-templates} flag is
used.  Additionally, the macro {\tt NO\_IMPLICIT\_TEMPLATES} should be
defined on the command line, using {\tt -D}.  This macro informs TPIE
that it should not rely on the presence of implicit template
instantiation.  In response to the fact that this macro is set, TPIE
defines a series of new macros with names of the form {\tt
  TEMPLATE\_INSTANTIATE\_*}.  
\index{TEMPLATE_INSTANTIATE_*@{\tt TEMPLATE\_INSTANTIATE\_*}|(}
Each of these macros can be used to
actually instantiate some set of functions and/or classes that TPIE
needs to provide a given operation.  These macros should be used at
the end of your source file in order to perform the proper
instantiations.

The {\tt TEMPLATE\_INSTANTIATE\_*} macros likely to be needed by TPIE
programmers are as follows:
\begin{description}
\item[{\tt TEMPLATE\_INSTANTIATE\_STREAMS(T)}] Instantiate AMI and
  BTE level streams of objects of type {\tt T}.  If your
  application uses streams of several types, this macro must be called
  once for each of them.
\item[{\tt TEMPLATE\_INSTANTIATE\_ISTREAM(T)}]
\item[{\tt TEMPLATE\_INSTANTIATE\_OSTREAM(T)}] Instantiate ASCII
  input and output scan management objects for the type {\tt T}.
  See Section~\ref{sec:ascii-io} for details on these objects.
  \index{scanning!ASCII I/O}
\item[{\tt TEMPLATE\_INSTANTIATE\_AMI\_MERGE}] Instantiate merging entry
  points for streams of objects of type {\tt T}.  Merging is described
  in Section~\ref{sec:merging}.
\item[{\tt TEMPLATE\_INSTANTIATE\_SORT\_OP(T)}]
\item[{\tt TEMPLATE\_INSTANTIATE\_SORT\_CMP(T)}]
\item[{\tt TEMPLATE\_INSTANTIATE\_SORT\_OBJ(T)}] Instantiate
  respectively operator, comparison function, and comparison object
  based sorting of objects of type {\tt T}.  See
  Section~\ref{sec:cmp-sorting} for details on these types of sorting.
\item[{\tt TEMPLATE\_INSTANTIATE\_KB\_SORT(T)}] 
\item[{\tt TEMPLATE\_INSTANTIATE\_KB\_SORT\_KEY(T,K)}] Instantiate key
  bucket distribution sorting of objects of type {\tt T}.  The latter
  form uses key {\tt K} for sorting.  Section~\ref{sec:kb-sorting}
  describes key bucket sorting.
\item[{\tt TEMPLATE\_INSTANTIATE\_STREAM\_ADD(T)}]
\item[{\tt TEMPLATE\_INSTANTIATE\_STREAM\_SUB(T)}]
\item[{\tt TEMPLATE\_INSTANTIATE\_STREAM\_MULT(T)}]
\item[{\tt TEMPLATE\_INSTANTIATE\_STREAM\_DIV(T)}]
  Instantiate elementwise arithmetic operations on streams of objects
  of type {\tt T} as described in Section~\ref{sec:elementwise}.
\item[{\tt TEMPLATE\_INSTANTIATE\_AMI\_MATRIX}]
  Instantiate dense matrices of objects of type {\tt T} and the
  standard operations on them.  Dense
  matrices are described in
  Section~\ref{sec:dense-mat}.\index{matrices!dense}
\item[{\tt TEMPLATE\_INSTANTIATE\_AMI\_SPARSE\_MATRIX}]
  Instantiate sparse matrices of objects of type {\tt T} and the
  standard operations on them.  Sparse
  matrices are described in
  Section~\ref{sec:dense-mat}.\index{matrices!sparse}
\end{description}
\index{TEMPLATE_INSTANTIATE_*@{\tt TEMPLATE\_INSTANTIATE\_*}|)}

In addition to instantiating functions and classes using the macros
described above, it is often necessary to explicitly instantiate
particular instances of AMI entry points for user supplied operation
management objects.  For example, suppose we declare a scan management
object class such as
\begin{verbatim}
class my_scan_class : AMI_scan_object {
public:
    AMI_err initialize(void);
    AMI_err operate(const int &in1, const int &in2, AMI_SCAN_FLAG *sfin,
                    float *out, AMI_SCAN_FLAG *sfout); 
}
\end{verbatim}
Then, in order to explicitly instantiate \verb|AMI_scan()| to use
objects of this type, we would use the following code:
\begin{verbatim}
template AMI_err AMI_scan(AMI_STREAM<int> *, AMI_STREAM<int> *, 
                          my_scan_class *, AMI_STREAM<float> *); 
\end{verbatim}
This instantiates an instance of \verb|AMI_scan()| that takes two input
streams of \verb|int|s, operates on them with an object of type
\verb|my_scan_class|, and produces an output stream of \verb|float|s.  
Note the correspondence between the types of input and output streams
and the types of the operands to the \verb|operate()| member function
of the class \verb|my_scan_class|.
\index{templates!instantiation|)}

\subsection{Compiler Flags}
\label{sec:comp-flags}

\index{compiler flags|(}
\index{compiler flags|)}

\subsection{Environment Variables}

\index{environment variables|(}

\index{environment variables!AMI_SINGLE_DEVICE_ENV@{\tt AMI\_SINGLE\_DEVICE\_ENV}}


\index{environment variables|)}


\chapter{Additional Examples} \label{ch:examples}
\index{examples}

This chapter contains some additional annotated examples of 
TPIE application code.

\section{Convex Hull}
\label{sec:convex-hull}
\index{convex hull|(}

The convex hull of a set of points in the plane is the smallest convex
polygon which encloses all of the points.  Graham's scan is a simple
algorithm for computing convex hulls.  It should be discussed in any
introductory book on computational geometry, such as~\cite{preparata:cg}.  Although Graham's scan was not originally designed for
external memory, it can be implemented optimally in this setting.
What is interesting about this implementation is that external memory
stacks are used within the implementation of a scan management object.

First, we need a data type for storing points.  We use the following
simple class, which is templated to handle any numeric type.

\begin{verbatim}
template<class T>
class point {
public:
    T x;
    T y;
    point() {};
    point(const T &rx, const T &ry) : x(rx), y(ry) {};
    ~point() {};

    inline int operator==(const point<T> &rhs) const {
        return (x == rhs.x) && (y == rhs.y);
    }
    inline int operator!=(const point<T> &rhs) const {
        return (x != rhs.x) || (y != rhs.y);
    }

    // Comparison is done by x.
    int operator<(const point<T> &rhs) const {
        return (x < rhs.x);
    }

    int operator>(const point<T> &rhs) const {
        return (x > rhs.x);
    }
    
    friend ostream& operator<<(ostream& s, const point<T> &p);
    friend istream& operator>>(istream& s, point<T> &p);
};
\end{verbatim}

Once the points are s by their $x$ values, we simply scan them to
produce the upper and lower hulls, each of which are stored as a stack
pointed to by the scan management object.  We then concatenate the
stacks to produce the final hull.  The code for computing the convex
hull of a set of points is thus

\begin{verbatim}
template<class T>
AMI_err convex_hull(AMI_STREAM< point<T> > *instream,
                    AMI_STREAM< point<T> > *outstream)
{
    AMI_err ae;

    point<T> *pt;

    AMI_stack< point<T> > uh((unsigned int)0, instream->stream_len());
    AMI_stack< point<T> > lh((unsigned int)0, instream->stream_len());

    AMI_STREAM< point<T> > in_sort;
        
    // Sort the points by x.

    ae = AMI_sort(instream, &in_sort);
    
    // Compute the upper hull and lower hull in a single scan.

    scan_ul_hull<T> sulh;

    sulh.uh_stack = &uh;
    sulh.lh_stack = &lh;
    
    ae = AMI_scan(&in_sort, &sulh);

    // Copy the upper hull to the output.

    uh.seek(0);
    
    while (1) {
        ae = uh.read_item(&pt);
        if (ae == AMI_ERROR_END_OF_STREAM) {
            break;
        } else if (ae != AMI_ERROR_NO_ERROR) {
            return ae;
        }

        ae = outstream->write_item(*pt);
        if (ae != AMI_ERROR_NO_ERROR) {
            return ae;
        }
    }
    
    // Reverse the lower hull, concatenating it onto the upper hull.

    while (lh.pop(&pt) == AMI_ERROR_NO_ERROR) {
        ae = outstream->write_item(*pt);
        if (ae != AMI_ERROR_NO_ERROR) {
            return ae;
        }
    }

    return AMI_ERROR_NO_ERROR;
}
\end{verbatim}

The only thing that remains is to define a scan management object that
is capable of producing the upper and lower hulls by scanning the
points.  According to the Graham's scan algorithm, we produce the
upper hull by moving forward in the $x$ direction, adding each
point we encounter to the upper hull, until we find one that induces a
concave turn on the surface of the hull.  We then move backwards
through the list of points that have been added to the hull,
eliminating points until a convex path is reestablished.  This process
is made efficient by storing the points on the hull so far in a stack.
The code for the scan management object, which relies on the function
\verb|ccw()| to actually determine whether a corner is
convex or not, is as follows:

\begin{verbatim}
template<class T>
class scan_ul_hull : AMI_scan_object {
public:
    AMI_stack< point <T> > *uh_stack, *lh_stack;

    scan_ul_hull(void);
    virtual ~scan_ul_hull(void);
    AMI_err initialize(void);
    AMI_err operate(const point<T> &in, AMI_SCAN_FLAG *sfin);
};

template<class T>
scan_ul_hull<T>::scan_ul_hull(void) : uh_stack(NULL), lh_stack(NULL)
{
}

template<class T>
scan_ul_hull<T>::~scan_ul_hull(void)
{
}

template<class T>
AMI_err scan_ul_hull<T>::initialize(void)
{
    return AMI_ERROR_NO_ERROR;
}


template<class T>
AMI_err scan_ul_hull<T>::operate(const point<T> &in,
                                 AMI_SCAN_FLAG *sfin)
{
    AMI_err ae;

    // If there is no more input we are done.
    if (!*sfin) {
        return AMI_SCAN_DONE;
    }

    if (!uh_stack->stream_len()) {

        // If there is nothing on the stacks then put the first point
        // on them.
        ae = uh_stack->push(in);
        if (ae != AMI_ERROR_NO_ERROR) {
            return ae;
        }

        ae = lh_stack->push(in);
        if (ae != AMI_ERROR_NO_ERROR) {
            return ae;
        }

    } else {

        // Add to the upper hull.

        {
            // Pop the last two points off.

            point<T> *p1, *p2;

            tp_assert(uh_stack->stream_len() >= 1, "Stack is empty.");
            
            uh_stack->pop(&p2);

            // If the point just popped is equal to the input, then we
            // are done.  There is no need to have both on the stack.
            
            if (*p2 == in) {
                uh_stack->push(*p2);
                return AMI_SCAN_CONTINUE;
            }
            
            if (uh_stack->stream_len() >= 1) {
                uh_stack->pop(&p1);
            } else {
                p1 = p2;
            }
            
            // While the turn is counter clockwise and the stack is
            // not empty pop another point.
            
            while (1) {                
                if (ccw(*p1,*p2,in) >= 0) {
                    // It does not turn the right way.  The points may
                    // be colinear.
                    if (uh_stack->stream_len() >= 1) {
                        // Move backwards to check another point.
                        p2 = p1;
                        uh_stack->pop(&p1);
                    } else {
                        // Nothing left to pop, so we can't move
                        // backwards.  We're done.
                        uh_stack->push(*p1);
                        if (in != *p1) {
                            uh_stack->push(in);
                        }
                        break;
                    }
                } else {
                    // It turns the right way.  We're done.
                    uh_stack->push(*p1);
                    uh_stack->push(*p2);
                    uh_stack->push(in);
                    break;
                }
            }
        }

        // Add to the lower hull.

        {
            // Pop the last two points off.

            point<T> *p1, *p2;

            tp_assert(lh_stack->stream_len() >= 1, "Stack is empty.");
            
            lh_stack->pop(&p2);

            // If the point just popped is equal to the input, then we
            // are done.  There is no need to have both on the stack.
            
            if (*p2 == in) {
                lh_stack->push(*p2);
                return AMI_SCAN_CONTINUE;
            }
            
            if (lh_stack->stream_len() >= 1) {
                lh_stack->pop(&p1);
            } else {
                p1 = p2;
            }
            
            // While the turn is clockwise and the stack is
            // not empty pop another point.
            
            while (1) {                
                if (ccw(*p1,*p2,in) <= 0) {
                    // It does not turn the right way.  The points may
                    // be colinear.
                    if (lh_stack->stream_len() >= 1) {
                        // Move backwards to check another point.
                        p2 = p1;
                        lh_stack->pop(&p1);
                    } else {
                        // Nothing left to pop, so we can't move
                        // backwards.  We're done.
                        lh_stack->push(*p1);
                        if (in != *p1) {
                            lh_stack->push(in);
                        }
                        break;
                    }
                } else {
                    // It turns the right way.  We're done.
                    lh_stack->push(*p1);
                    lh_stack->push(*p2);
                    lh_stack->push(in);
                    break;
                }
            }
        }       
    }

    return AMI_SCAN_CONTINUE;    
}
\end{verbatim}

The function \verb|ccw()| computes twice the signed area of a triangle in
the plane by evaluating a 3 by 3 determinant.  The result is positive
if and only if the the three points in order form a counterclockwise
cycle.

\begin{verbatim}
template<class T>
T ccw(const point<T> &p1, const point<T> &p2, const point<T> &p3)
{
    T sa;
    
    sa = ((p1.x * p2.y - p2.x * p1.y) -
          (p1.x * p3.y - p3.x * p1.y) +
          (p2.x * p3.y - p3.x * p2.y));

    return sa;
}
\end{verbatim}
\index{convex hull|)}

\section{List-Ranking}
\label{sec:list-ranking}
\index{list ranking|(}

List ranking is a fundamental problem in graph theory.  The problem is
as follows: We are given the directed edges of a linked list in some
arbitrary order.  Each edge is an ordered pair of node ids.  The first
is the source of the edge and the second is the destination of the
edge.  Our goal is to assign a weight to each edge corresponding to
the number of edges that would have to be traversed to get from the
head of the list to that edge.

The code given below solves the list ranking problem using a simple
randomized algorithm due to Chiang, Goodrich, Grove, Tamassia,
Vengroff, and Vitter, which appears in the proceedings of SODA '95.
As was the case in the code examples in the tutorial in
Chapter~\ref{ch:tutorial}, \verb|#include| statements
for header files and definitions of some classes and functions as well
as some error and consistency checking code are left out so that the
reader can concentrate on the more important details of how TPIE is
used.  A complete ready to compile version of this code is included in
the TPIE source distribution.

First, we need a class to represent edges.  Because the algorithm will
set a flag for each edge and then assign weights to the edges, we
include fields for these values.

\begin{verbatim}
class edge {
public:
    unsigned long int from;        // Node it is from
    unsigned long int to;          // Node it is to
    unsigned long int weight;      // Position when ranked.
    bool flag;            // A flag used to randomly select some edges.

    friend ostream& operator<<(ostream& s, const edge &e);
};    
\end{verbatim}

As the algorithm runs, it will sort the edges.  At times this will be
done by their sources and at times by their destinations.  The
following simple functions are used to compare these values:

\begin{verbatim}
int edgefromcmp(CONST edge &s, CONST edge &t)
{
    return (s.from < t.from) ? -1 : ((s.from > t.from) ? 1 : 0);
}
  
int edgetocmp(CONST edge &s, CONST edge &t)
{
    return (s.to < t.to) ? -1 : ((s.to > t.to) ? 1 : 0);
}
\end{verbatim}

The first step of the algorithm is to assign a randomly chosen flag,
whose value is 0 or 1 with equal probability, to each edge.  This is
done using \verb|AMI_scan()| with a scan management object of the
class \verb|random_flag_scan|, which is defined as follows:

\begin{verbatim}
class random_flag_scan : AMI_scan_object {
public:
    AMI_err initialize(void);  
    AMI_err operate(const edge &in, AMI_SCAN_FLAG *sfin,
                    edge *out, AMI_SCAN_FLAG *sfout);
};

AMI_err random_flag_scan::initialize(void) {
    return AMI_ERROR_NO_ERROR;
}

AMI_err random_flag_scan::operate(const edge &in, AMI_SCAN_FLAG *sfin,
                                  edge *out, AMI_SCAN_FLAG *sfout)
{ 
    if (!(sfout[0] = *sfin)) {
        return AMI_SCAN_DONE;
    }
    *out = in;
    out->flag = (random() & 1);
    
    return AMI_SCAN_CONTINUE;
}
\end{verbatim}

The next step of the algorithm is to separate the edges into an active
list and a cancel list.  In order to do this, we sort one copy of the
edges by their sources (using \verb|edgefromcmp|) and sort another copy by
their destinations (using \verb|edgetocmp|).  We then call
\verb|AMI_scan()| to scan the two lists and produce an active list and
a cancel list.  A scan management object of class
\verb|separate_active_from_cancel|, which is defined below, is used.

\begin{verbatim}
////////////////////////////////////////////////////////////////////////
// separate_active_from_cancel
//
// A class of scan object that takes two edges, one to a node and one 
// from it, and writes an active edge and possibly a canceled edge.
//
// Let e1 = (x,y,w1,f1) be the first edge and e2 = (y,z,w2,f2) the second.
// If e1's flag (f1) is set and e2's (f2) is not, then we write 
// (x,z,w1+w2,?) to the active list and e2 to the cancel list.  The
// effect of this is to bridge over the node y with the new active edge.
// f2, which was the second half of the bridge, is saved in the cancellation
// list so that it can be ranked later after the active list is recursively 
// ranked.
//
// Since all the flags should have been set randomly before this function
// is called, the expected size of the active list is 3/4 the size of the
// original list.
////////////////////////////////////////////////////////////////////////
class separate_active_from_cancel : AMI_scan_object {
public:
    AMI_err initialize(void);
    AMI_err operate(CONST edge &e1, CONST edge &e2, AMI_SCAN_FLAG *sfin,
                    edge *active, edge *cancel, AMI_SCAN_FLAG *sfout);
};

AMI_err separate_active_from_cancel::initialize(void)
{
    return AMI_ERROR_NO_ERROR;
}

// e1 is from the list of edges sorted by where they are from.
// e2 is from the list of edges sorted by where they are to.
AMI_err separate_active_from_cancel::operate(CONST edge &e1,
                                             CONST edge &e2, 
                                             AMI_SCAN_FLAG *sfin,
                                             edge *active, edge *cancel, 
                                             AMI_SCAN_FLAG *sfout)
{
    // If we have both inputs.
    if (sfin[0] && sfin[1]) {
        // If they have a node in common we may be in a bridging situation.
        if (e2.to == e1.from) {
            // We will write to the active list no matter what.
            sfout[0] = 1;
            *active = e2;
            if (sfout[1] = (e2.flag && !e1.flag)) {
                // Bridge.  Put e1 on the cancel list and add its
                // weight to the active output.
                active->to = e1.to;
                active->weight += e1.weight;
                *cancel = e1;
                sfout[1] = 1;
            } else {
                // No bridge.
                sfout[1] = 0;
            }
        } else {
            // They don't have a node in common, so one of them needs
            // to catch up with the other.  What happened is that
            // either e2 is the very last edge in the list or e1 is
            // the very first or we just missed a bridge because of
            // flags.
            sfout[1] = 0;                
            if (e2.to > e1.from) {
                // e1 is behind, so just skip it.
                sfin[1] = 0;
                sfout[0] = 0;
            } else {
                // e2 is behind, so put it on the active list.
                sfin[0] = 0;
                sfout[0] = 1;
                *active = e2;
            }
        }
        return AMI_SCAN_CONTINUE;
    } else {
        // If we only have one input, either just leave it active.
        if (sfin[0]) {
            *active = e1;
            sfout[0] = 1;
            sfout[1] = 0;
            return AMI_SCAN_CONTINUE;
        } else if (sfin[1]) {
            *active = e2;
            sfout[0] = 1;
            sfout[1] = 0;
            return AMI_SCAN_CONTINUE;
        } else {
            // We have no inputs, so we're done.
            sfout[0] = sfout[1] = 0;            
            return AMI_SCAN_DONE;
        }
    }
}
\end{verbatim}

The next step of the algorithm is to strip the cancelled edges away
from the list of all edges.  The remaining active edges will form a
recursive subproblem.  Again, we use a scan management object, this
time of the class \verb|strip_active_from_cancel|, which is defined as
follows:

\begin{verbatim}
////////////////////////////////////////////////////////////////////////
//
// strip_cancel_from_active
//
// A scan management object to take an active list and remove the
// smaller weighted edge of each pair of consecutive edges with the
// same destination.  The purpose of this is to strip edges out of the
// active list that were sent to the cancel list.
//
////////////////////////////////////////////////////////////////////////
class strip_cancel_from_active : AMI_scan_object {
private:
    bool holding;
    edge hold;
public:
    AMI_err initialize(void);  
    AMI_err operate(const edge &active, AMI_SCAN_FLAG *sfin,
                    edge *out, AMI_SCAN_FLAG *sfout);
};

AMI_err strip_cancel_from_active::initialize(void) {
    holding = false;
    return AMI_ERROR_NO_ERROR;
}

// Edges should be sorted by destination before being processed by
// this object.
AMI_err strip_cancel_from_active::operate(const edge &active,
                                  AMI_SCAN_FLAG *sfin,
                                  edge *out, AMI_SCAN_FLAG *sfout)
{
    // If no input then we're done, except that we might still be
    // holding one.
    if (!*sfin) {
        if (holding) {
            *sfout = 1;
            *out = hold;
            holding = false;
            return AMI_SCAN_CONTINUE;
        } else {
            *sfout = 0;
            return AMI_SCAN_DONE;
        }
    }

    if (!holding) {
        // If we are not holding anything, then just hold the current
        // input.
        hold = active;
        holding = true;
        *sfout = 0;
    } else {
        *sfout = 1;
        
        if (active.to == hold.to) {
            if (active.weight > hold.weight) {
                *out = active;
            } else {
                *out = hold;
            }

            holding = false;
        } else {
            *out = hold;
            hold = active;
        }
    }

    return AMI_SCAN_CONTINUE;
}
\end{verbatim}

After recursion, we must patch the cancelled edges back into the
recursively ranked list of active edges.  This is done using a scan
with a scan management object of the class
\verb|interleave_active_cancel|, which is implemented as follows:

\begin{verbatim}
////////////////////////////////////////////////////////////////////////
// interleave_active_cancel
//
// This is a class of merge object that merges two lists of edges
// based on their to fields.  The first list of edges should be active
// edges, while the second should be cancelled edges.  When we see two
// edges with the same to field, we know that the second was cancelled
// when the first was made active.  We then fix up the weights and
// output the two of them, one in the current call and one in the next
// call.
//
// The streams this operates on should be sorted by their terminal
// (to) nodes before AMI_scan() is called.
// 
////////////////////////////////////////////////////////////////////////

class patch_active_cancel : AMI_scan_object {
private:
    bool holding;
    edge hold;
public:
    AMI_err initialize(void);
    AMI_err operate(CONST edge &active, CONST edge &cancel,
                    AMI_SCAN_FLAG *sfin,
                    edge *patch, AMI_SCAN_FLAG *sfout);
};

AMI_err patch_active_cancel::initialize(void)
{
    holding = false;
    return AMI_ERROR_NO_ERROR;
}

AMI_err patch_active_cancel::operate(CONST edge &active, CONST edge &cancel,
                                     AMI_SCAN_FLAG *sfin,
                                     edge *patch, AMI_SCAN_FLAG *sfout)
{
    // Handle the special cases that occur when holding an edge and/or
    // completely out of input.
    if (holding) {
        sfin[0] = sfin[1] = 0;
        *patch = hold;
        holding = false;
        *sfout = 1;
        return AMI_SCAN_CONTINUE;
    } else if (!sfin[0]) {
        *sfout = 0;
        return AMI_SCAN_DONE;
    }

    if (!sfin[1]) {
        // If there is no cancel edge (i.e. all have been processed)
        // then just pass the active edge through.
        *patch = active;
    } else {
        if (holding = (active.to == cancel.to)) {
            patch->from = active.from;
            patch->to = cancel.from;
            patch->weight = active.weight - cancel.weight;
            hold.from = cancel.from;
            hold.to = active.to;
            hold.weight = active.weight;
        } else {
            *patch = active;
            sfin[1] = 0;
        }
    }

    *sfout = 1;
    return AMI_SCAN_CONTINUE;

}
\end{verbatim}

Finally, here is the actual function to rank the list.

\begin{verbatim}
////////////////////////////////////////////////////////////////////////
// list_rank()
//
// This is the actual recursive function that gets the job done.
// We assume that all weights are 1 when the initial call is made to
// this function.
//
// Returns 0 on success, nonzero otherwise.
////////////////////////////////////////////////////////////////////////

int list_rank(AMI_STREAM<edge> *istream, AMI_STREAM<edge> *ostream)
{
    AMI_err ae;
    
    off_t stream_len = istream->stream_len();

    AMI_STREAM<edge> *edges_rand;
    AMI_STREAM<edge> *active;
    AMI_STREAM<edge> *active_2;
    AMI_STREAM<edge> *cancel;
    AMI_STREAM<edge> *ranked_active;

    AMI_STREAM<edge> *edges_from_s;
    AMI_STREAM<edge> *cancel_s;
    AMI_STREAM<edge> *active_s;
    AMI_STREAM<edge> *ranked_active_s;

    // Scan/merge management objects.
    random_flag_scan my_random_flag_scan;
    separate_active_from_cancel my_separate_active_from_cancel;
    strip_cancel_from_active my_strip_cancel_from_active;
    patch_active_cancel my_patch_active_cancel;
    
    // Check if the recursion has bottomed out.  If so, then read in the
    // array and rank it.

    {
        size_t mm_avail;
        
        MM_manager.available(&mm_avail);

        if (stream_len * sizeof(edge) < mm_avail / 2) {
            edge *mm_buf = new edge[stream_len];
            istream->seek(0);
            istream->read_array(mm_buf,&stream_len);
            main_mem_list_rank(mm_buf,stream_len);
            ostream->write_array(mm_buf,stream_len);
            return 0;
        }
    }
    
    // Flip coins for each node, setting the flag to 0 or 1 with equal
    // probability.

    edges_rand = new AMI_STREAM<edge>;
    
    AMI_scan(istream, &my_random_flag_scan, edges_rand);

    // Sort one stream by source.  The original input was sorted by
    // destination, so we don't need to sort it again.

    edges_from_s = new AMI_STREAM<edge>;

    ae = AMI_sort(edges_rand, edges_from_s, edgefromcmp);

    // Scan to produce and active list and a cancel list.

    active = new AMI_STREAM<edge>;
    cancel = new AMI_STREAM<edge>;

    ae = AMI_scan(edges_from_s, edges_rand,
                  &my_separate_active_from_cancel,
                  active, cancel);

    delete edges_from_s;
    delete edges_rand;
    
    // Strip the edges that went to the cancel list out of the active list.

    active_s = new AMI_STREAM<edge>;

    ae = AMI_sort(active, active_s, edgetocmp);

    delete active;

    active_2 = new AMI_STREAM<edge>;

    ae = AMI_scan(active_s,
                  &my_strip_cancel_from_active,
                  active_2);

    delete active_s;

    // Recurse on the active list.  The list we pass in is sorted by
    // destination.  The recursion will return a list sorted by
    // source.

    ranked_active = new AMI_STREAM<edge>;
    
    list_rank(active_2, ranked_active);

    delete active_2;

    cancel_s = new AMI_STREAM<edge>;

    AMI_sort(cancel, cancel_s, edgetocmp);

    delete cancel;

    // The output of the recursive call is not necessarily sorted by
    // destination.  We'll make it so before we try to merge in the
    // cancel list.

    ranked_active_s = new AMI_STREAM<edge>;

    AMI_sort(ranked_active, ranked_active_s, edgetocmp);

    delete ranked_active;
    
    // Now merge the recursively ranked active list and the sorted 
    // cancel list.

    ae = AMI_scan(ranked_active_s, cancel_s,
                  &my_patch_active_cancel, ostream);

    delete ranked_active_s;
    delete cancel_s;
    
    return 0;
}
\end{verbatim}

Our recursion bottoms out when the problem is small enough to fit
entirely in main memory, in which case we read it in and call a
function to rank a list in main memory.  The details of this function
are omitted here.

\begin{verbatim}
////////////////////////////////////////////////////////////////////////
// main_mem_list_rank()
//
// This function ranks a list that can fit in main memory.  It is used
// when the recursion bottoms out.
//
////////////////////////////////////////////////////////////////////////

int main_mem_list_rank(edge *edges, size_t count)
{
    // Rank the list in main memory

    ...
        
    return 0;  
}
\end{verbatim}
\index{list ranking|)}

\section{NAS Parallel Benchmarks}

Code designed to implement external memory versions of a number of the
NAS parallel benchmarks is included with the TPIE distribution.
Examine this code for examples of how the various primitives TPIE
provides can be combined into powerful applications capable of solving
real-world problems.

Detailed descriptions of the NAS parallel benchmarks are available
from the \htmladdnormallink{NAS Parallel Benchmark Home Page}%
{http://www.nas.nasa.gov/NAS/NPB/}
\begin{latexonly}
at URL \verb|http://www.nas.nasa.gov/NAS/NPB/|.
\end{latexonly}

\part{Reference}

\chapter{AMI Programmers' Reference}

\section{AMI Streams}
\label{sec:ami_stream-ref}

An AMI stream\index{streams!AMI} is nothing more than an abstraction
of an ordered set of objects of any one class which is stored in
secondary memory.  In some applications, the elements of a stream
might be nothing more than integers.  In others, they might be objects
of an arbitrarily complex user defined class.  Creating a stream of
objects of class \verb|foo| called \verb|foo_stream| requires nothing
more than the definition

\begin{verbatim}
AMI_STREAM<foo> foo_stream;
\end{verbatim}

\verb|AMI_STREAM| is a macro that resolves to a class
template declared to match the underlying semantics of the target I/O
architecture by using an appropriate BTE\index{block transfer engine}
(see Section~\ref{sec:ref-bte}) and MM 
(see Section~\ref{sec:ref-mm}).


\subsection{Substreams}

It is possible to construct one AMI stream that is actually a
substream of another.  In fact, if one so desires, one can construct
substreams of substreams of subtreams {\em ad infinitum}.  A substream
is defined as a contiguous range of objects from within the ordered
collection of objects that make up the stream.

In order to create a substream, we use a pseudo-constructor called
\verb|new_substream()|, which is declared as follows:
\begin{verbatim}
AMI_err AMI_stream_single<T>::new_substream(AMI_stream_type st,
                                            off_t sub_begin,
                                            off_t sub_end,
                                            AMI_base_stream<T> **sub_stream)
\end{verbatim}
The stream type is one of \verb|AMI_READ_STREAM|,
\verb|AMI_WRITE_STREAM|, or \verb|AMI_READ_WRITE_STREAM|, which define
what operation will be permitted on this substream.  The offsets
\verb|sub_begin| and \verb|sub_end| define where in the stream the new
substream will begin.  Upon completion, \verb|*substream| is set to
point to the newly allocated and created substream.

The reason we do not use a real constructor is to get around the fact
that constructors can not be virtual.  Because \verb|new_substream()|
is not a constructor, but rather a function each particular
implementation of which calls an appropriate constructor, it can be a
pure virtual function in the stream base class, which forces it to be
defined for all actual stream implementations.  This is discussed in
more detail in Sections~\ref{sec:ref-ami} and~\ref{sec:ref-bte}, which
discuss the implementation of the AMI and BTE in more detail.

\section{AMI Errors}
\label{sec:ami-errors}

\index{error|(}
AMI entry points typically return error codes of the enumerated type
\verb|AMI_err|.  Member functions of operation management
objects\index{operation management objects} also typically return this
type.  Possible values for error codes include those listed below.  It
is expected that in future releases of TPIE, many of these error codes
will be replaced by exceptions.  Exceptions are not currently used by
TPIE becasue the {\tt g++} compiler does not fully support them.

\subsection{General Error Codes}

\begin{description}
\item[{\tt AMI\_ERROR\_NO\_ERROR}] No error occured.  The call the the
  entry point returned normally.
\item[{\tt AMI\_ERROR\_IO\_ERROR}] A low level I/O error occured.
\item[{\tt AMI\_ERROR\_END\_OF\_STREAM}] An attempt was made to read
  past the end of a stream or write past the end of a substream.
\item[{\tt AMI\_ERROR\_READ\_ONLY}] An attempt was made to write to a
  read-only stream.
\item[{\tt AMI\_ERROR\_OS\_ERROR}]  An unexpected operating system
  error occurred.  Details should appear in the log file if logging is
  enabled.  See Section~\ref{sec:logging}.
\item[{\tt AMI\_ERROR\_BASE\_METHOD}] An attempt was made to call a
  member function of the virtual base class of {\tt AMI\_STREAM}.  This
  indicates a bug in the implementation of AMI streams.
\item[{\tt AMI\_ERROR\_BTE\_ERROR}] An error occurred at the BTE
  level.  
\item[{\tt AMI\_ERROR\_MM\_ERROR}] An error occurred within the memory
  manager.
\item[{\tt AMI\_ERROR\_OBJECT\_INITIALIZATION}] An AMI entry point was
  not able to properly initialize the operation management object that
  was passed to it.  This generally indicates a bug in the operation
  management object's initialization code.
%\item[{\tt AMI\_ERROR\_PERMISSION\_DENIED}]
\item[{\tt AMI\_ERROR\_INSUFFICIENT\_MAIN\_MEMORY}] The MM could not
  make adequate main memory available to complete the requested
  operation.  Many operations adapt themselves to use whatever main
  memory is available, but in some cases, when memory is extremely
  tight, they may not be able to function.
\item[{\tt AMI\_ERROR\_INSUFFICIENT\_AVAILABLE\_STREAMS}]
  The AMI could not allocate enough intermediate streams to perform
  the requested operation.  Certain operating system restrictions
  limit the number of streams that can be created on certain
  platforms.  Only in unusual circumstances, such as when the
  application itself has a very large number of open streams, will
  this error occur. 
\item[{\tt AMI\_ERROR\_ENV\_UNDEFINED}]
  An environment variable necessary to initialize the AMI was not defined.
\item[{\tt AMI\_ERROR\_BIT\_MATRIX\_BOUNDS}]
  A bit matrix larger than the number of bits in an offset into a
  stream was passed to \verb|ami_gp()|.
\item[{\tt AMI\_ERROR\_NOT\_POWER\_OF\_2}]
  The length of a stream on which a bit permutation was to be
  performed is not a power of two.
\item[{\tt AMI\_MATRIX\_BOUNDS}] An attempt was made to perform a
  matrix operation on matrices whose bounds did not match appropriately.
\end{description}


\subsection{Return Values for Scan Management Objects}

More information on the precise semantics of these values appears in
Section~\ref{sec:ref-ami-scan}.
\begin{description}
\item[{\tt AMI\_SCAN\_CONTINUE}] Tells \verb|AMI_scan()| to continue
  to call the \verb|operate()| member function of the scan management
  object with more data.
\item[{\tt AMI\_SCAN\_DONE}] Tells \verb|AMI_scan()| that the scan is
  complete. 
\end{description}

\subsection{Return Values for Merge Management Objects}

More information on the precise semantics of these values appears in
Section~\ref{sec:ref-ami-merge}.
\begin{description}
\item[{\tt AMI\_MERGE\_CONTINUE}] Tells \verb|AMI_merge()| to continue
  to call the \verb|operate()| member function of the scan management
  object with more data.
\item[{\tt AMI\_MERGE\_DONE}] Tells \verb|AMI_merge()| that the scan is
  complete. 
\item[{\tt AMI\_MERGE\_OUTPUT}]  Tells \verb|AMI_merge()| that the
  last call generated output for the output stream.
\item[{\tt AMI\_MERGE\_READ\_MULTIPLE}]  Tells \verb|AMI_merge()| that
  more than one input object was consumed and thus the input flags
  should be consulted.
\end{description}

\index{error|)}

\section{AMI Entry Points}

\index{AMI entry point}\index{entry point!AMI|see{AMI entry point}}

% This section describes all the commonly used AMI entry points.  

\subsection{Scanning}
\label{sec:ref-ami-scan}

\index{scanning|(}

The simplest polymorph of \verb|AMI_scan()| is
\begin{verbatim}
    AMI_err AMI_scan(ST *smo, AMI_STREAM<T> *outstream);
\end{verbatim}
which generates an output stream of objects of type \verb|T|.
\verb|smo| is a pointer to a scan management object of used defined
class \verb|ST|.  \verb|ST| should provide member functions {\tt
  AMI\_err initialize(void)} and {\tt AMI\_err operate(T *out1,
  AMI\_SCAN\_FLAG *sf)}.

Scanning can also read and process an input stream of objects of type
\verb|T|.  The polymorph that does this looks like
\begin{verbatim}
    AMI_err AMI_scan(AMI_STREAM<T> *instream, ST *smo);
\end{verbatim}
Again, \verb|smo| is a pointer to a scan management object of used
defined class \verb|ST|.  \verb|ST| should provide member functions
{\tt AMI\_err initialize(void)} and {\tt AMI\_err operate(const T
  \&in1, AMI\_SCAN\_FLAG *sf)}.

\verb|AMI_scan()| may also read multiple input streams, each
potentially of a different type, and write multiple output streams,
each potentially of a different type.  This is done using the polymorph
\index{scanning!multi-type}
\begin{verbatim}
    AMI_err AMI_scan(AMI_STREAM<T1> *instream1, 
                     AMI_STREAM<T2> *instream2, ..., 
                     ST *smo, 
                     AMI_STREAM<U1> *os1, 
                     AMI_STREAM<U1> *os2, ...);
\end{verbatim}
The scan management object class \verb|ST| should have an operate
method taking the appropriate number and type of operands.  For
example, {\tt AMI\_err operate(const T1 \&in1, const T2 \&in2, ...,
  AMI\_SCAN\_FLAG *sfin, U1 *out1, U2 *out2, ..., AMI\_SCAN\_FLAG
  *sfout)}.  In the current implementation of TPIE there can be
between zero and four inputs and zero and four outputs.


\subsubsection{Scan Management Objects}  
\index{operation management objects!scan|(}

A scan management object class must provide two member functions for
\verb|AMI_scan()| to call.  The first is
\begin{verbatim}
    AMI_err initialize(void);
\end{verbatim}
\verb|initialize()| initializes the object to prepare it for a scan.
This member function is called once by each call to \verb|AMI_scan()|
in order to initialize the scan managment object before any data
processing takes place.  This function should return
\verb|AMI_ERROR_NO_ERROR| if successful, or an appropriate error
otherwise.  See Section~\ref{sec:ami-errors} for a list of error
codes.

Most of the work done is a scan is typically done in by the scan
management objects's member function
\begin{verbatim}
    AMI_err operate([const T1 &in1, ...,  AMI\_SCAN\_FLAG *sfin, ] 
                    [ U1 *out1, ..., AMI\_SCAN\_FLAG *sfout]);
\end{verbatim}

Either one or more input objects or one or more output parameters must
be specified.  These must correspond in number and type to the streams
passed to the polymorph of \verb|AMI_scan()| with which this scan
management object is to be used.

If there are inputs, \verb|sfin| points to an array of flags, one for
each input parameter.  Flags that are set (non-zero) indicate that the
corresponding input parameters are valid.  If the input flags are left
untouched, it is assumed that the input parameters were processed.  If
one or more are cleared (set to zero) then the it is assumed that the
corresponding inputs were not processed and should be presented again
on the next call to \verb|operate()|.  This permits out of step
scanning\index{scanning!out of step}, as illustrated in
Section~\ref{sec:out-of-step}.

The output parameters are used to store objects to be written to the
output streams.  The output flags are set by \verb|operate()| to
indicate which outputs are valid and should be written to the output
streams.

The return value of \verb|operate()| will normally be either
\verb|AMI_SCAN_CONTINUE|, which indicates that the function should be
called again with any taken input parameters replaced by the next
objects from the streams they came from, of \verb|AMI_SCAN_DONE|,
which indicates that the scan is complete and no more input needs to
be processed.  Note that \verb|operate()| may continue to return
\verb|AMI_SCAN_CONTINUE| even when the input flags indicate that their
is no more input to be processed.  This is useful if the scan
management object maintains some internal state that must be written
out after all input has been processed.

There are numerous examples of scan managment objects in
Section~\ref{sec:scanning} as well as in the test applications that
appear in the TPIE distribution.

\index{operation management objects!scan|)}
\index{scanning|)}

\subsection{Merging}
\label{sec:ref-ami-merge}
\index{merging|(}

To merge a number of streams in a single pass, TPIE provides the entry
point.

\begin{verbatim}
AMI_err AMI_single_merge(AMI_STREAM<T> **instreams, arity_t arity,
                         AMI_STREAM<T> *outstream, M *m_obj);
\end{verbatim}

\verb|instreams| is an array of pointers to the input streams, all of
which are streams of objects of type \verb|T|.  \verb|arity| is the
number of input streams.  \verb|outstream| is the output stream.
Finally, \verb|m_obj| points to a merge management object which will
control the merge.  Merge management objects are described below.
 
If the number of streams is large enough that all cannot be properly
buffered in the available main memory, then this function will fail,
returning \verb|AMI_ERR_INSUFFICIENT_MAIN_MEMORY|.  Most programs are
unlikely to need to call \verb|AMI_single_merge()| directly.  

More commonly, programs will wish to partition a stream into
substreams small enough to fit in main memory, operate on each in main
memory, and then merge them together, possibly in several passes if
low memory conditions dictate.  TPIE provides the entry point to do
this, which is
\begin{verbatim}
AMI_err AMI_partition_and_merge(AMI_STREAM<T> *instream,
                                AMI_STREAM<T> *outstream, M *m_obj);
\end{verbatim}
This entry point takes care of all the details of determining how much
main memory is available, how big the initial substreams can be, how
many streams can be merged at a time, and how many levels of merging
must take place.

\subsubsection{Merge Management Objects}  
\index{operation management objects!merge|(} A merge management object
must provide \verb|initialize()| and \verb|operate()| member
functions, whose functions are analogous to their namesakes for scan
management objects.  They should be declared as
\begin{verbatim}
    AMI_err initialize(arity_t arity, const T * const *in,
                       AMI_merge_flag *taken_flags,
                       int &taken_index);
\end{verbatim}
and
\begin{verbatim}
    AMI_err operate(const T * const *in, AMI_merge_flag *taken_flags,
                    int &taken_index, T *out);
\end{verbatim}
The arguments to \verb|initialize()| are \verb|arity|, the number of
input streams in the merge, \verb|in| a pointer to an array of
pointers to input objects, each of which is the first object appearing
in one of the input streams,  \verb|taken_flags| an array of flags
indicating which of the inputs are present (i.e. which of the input
streams is not empty), and a pointer to an output object.

The typical behavior of an \verb|initialize()| member function for a
merge management object is to place all the input objects into a data
structure and then return \verb|AMI_MERGE_READ_MULTIPLE| to indicate
that it took all the inputs which were indicated to be valid by
\verb|taken_flags|.  \verb|initialize| need not process all inputs; it
can turn off any flags in \verb|taken_flags| corresponding to inputs
that should be presented to \verb|operate()|.  Alternatively, it can
set \verb|taken_index| to the index of a single input it processed and
return \verb|AMI_MERGE_CONTINUE|.

The \verb|operate()| member function for a merge management object is
called repeatedly to process input objects.  Typically, this member
function will choose one input object to process, and set
\verb|taken_index| to the index of the pointer to that object in the
input array.  This object is then typically added to a dynamic data
structure maintained by the merge management object.  If output is
generated, for example by removing an object from the dynamic data
structure, \verb|operate()| should return \verb|AMI_MERGE_OUTPUT|,
otherwise, it returns either \verb|AMI_MERGE_CONTINUE| to indicate that
more input should be presented, or \verb|AMI_MERGE_DONE| to indicate
that the merge has completed.  

Alternatively, \verb|operate()| can clear the elements of
\verb|taken_flags| that correspond to inputs it does not currently
wish to process, and then return \verb|AMI_MERGE_READ_MULTIPLE|.  This
is generally undesirable because, if only one input is taken, it is
far slower than using \verb|taken_index| to indicate which input was
taken.  The merge management object must clear all other flags, and
then TPIE must can all the flags to see which inputs were or were not 
processed.

Any merge management object that is used with the entry point
\verb|AMI_partition_and_merge()| needs to provide a member function to
operate on substreams of data that are small enough to fit into main
memory.  This member function is
\begin{verbatim}
    AMI_err main_mem_operate(T* mm_stream, size_t len);
\end{verbatim}
\verb|mm_stream| is a pointer to an array of objects that have
been read into main memory.  \verb|len| is the number of objects in
the array.

Finally, because merge management objects are allowed to maintain data
structures whose size is linear in the number of input streams being
processed, there must be some mechanism to communicate their memory
requirements to TPIE.  This is done through the following two member
functions:
\begin{verbatim}
    size_t space_usage_overhead(void);
    size_t space_usage_per_stream(void);
\end{verbatim}
The former should return an upper bound on the amount of main memory
the object will allocate in addition to the portion that is linear in
the number of streams.  The latter should return the amount of
additional main memory needed per input stream.

There are examples of merge management objects in
Section~\ref{sec:merging} as well as in the test applications that
appear in the TPIE distribution.
\index{operation management objects!merge|)}
\index{merging|)}

\subsection{Comparison Sorting}
\label{sec:ref-ami-sort}

\index{sorting!comparison|(}

In order to provide maximum flaxibility to programmers, comparison
sorting a set of objects in a stream can be done in three different
ways.  The particular choice of method will depend on the exact
context in which the sort is being performed.

All three polymorhps of \verb|AMI_sort()| take an argument
\verb|instream|, which is a pointer to the input stream, and
\verb|outstream|, which is a pointer to the output stream to which the
sorted results are to be written.
The first polymoph takes no additional arguments.  
\begin{verbatim}
AMI_err AMI_sort(AMI_STREAM<T> *instream, AMI_STREAM<T> *outstream)
\end{verbatim}
In order to
determine the relative order of two input objects in the output, it
uses the operator \verb|<|.  Thus, the type \verb|T| of objects in the
stream must have a member \verb|operator<|. 

The second polymorph relies on a user supplied comparison function,
similar to that used in the familiar C library function \verb|qsort()|.
\begin{verbatim}
AMI_err AMI_sort(AMI_STREAM<T> *instream, AMI_STREAM<T> *outstream,
                 int (*cmp)(CONST T&, CONST T&));
\end{verbatim}
When called, \verb|cmp(a,b)| should return a negative value if $a$ is
less that $b$, a positive value if $a$ is greater than $b$, and
\verb|0| if \verb|a| and \verb|b| are equal.

It is often useful to use a comparison function when the type of
object being sorted has several fields, and we sometime wish to sort
on one field and sometimes on another.  Two differenct comparison
functions can be defined, eliminating the need to provide a \verb|<|
operator that is compile-time bound to perform comparisons is a
particular way.

The final polymorph of \verb|AMI_sort()| relise on a comparator class.
\begin{verbatim}
AMI_err AMI_sort(AMI_STREAM<T> *instream, AMI_STREAM<T> *outstream,
                 comparator<T> *cmp)
\end{verbatim}
Instead of defining a comparison function, the programmer defines a
comparator class, which has a member function 
\begin{verbatim}
    int compare(const T& t1, const T& t2);
\end{verbatim}
which behaves exactly as the comparison function described above.

Examples of comparison based sorting appear in
Section~\ref{sec:cmp-sorting} as well as in the test applications that 
appear in the TPIE distribution.  Section~\ref{sec:list-ranking}
illustrates the use of multiple comparison functions to sort streams
of objects in different ways.
\index{sorting!comparison|)}

\subsection{Key Bucket Sorting}
\label{sec:ref-ami-kb-sort}

\index{sorting!key bucket|(}

\begin{verbatim}
AMI_err AMI_kb_dist()
\end{verbatim}

\begin{verbatim}
AMI_err AMI_kb_sort()
\end{verbatim}

\begin{verbatim}
AMI_err AMI_kb_dist_key()
\end{verbatim}

\begin{verbatim}
AMI_err AMI_kb_sort_key()
\end{verbatim}
\index{sorting!key bucket|)}

\subsection{General Permuting}
\label{sec:ref-ami-gp}

\index{permutation!general|(}

\begin{verbatim}
AMI_err AMI_general_permute(AMI_STREAM<T> *instream, 
                            AMI_STREAM<T> *outstream, 
                            AMI_gen_perm_object *gpo);
\end{verbatim}
\index{permutation!general|)}

\subsection{Bit Permuting}
\label{sec:ref-ami-bp}

\index{permutation!bit|(}
\begin{verbatim}
AMI_err AMI_BMMC_permute(AMI_STREAM<T> *instream, 
                         AMI_STREAM<T> *outstream, 
                         AMI_bit_perm_object *bpo);
\end{verbatim}
\index{permutation!bit|)}

\subsection{Dense Matrices}
\label{sec:ref-ami-matrix}

\index{matrices!dense|(}
\index{matrices!dense|)}

\subsection{Sparse Matrices}
\label{sec:ref-ami-sm}

\index{matrices!sparse|(}
\index{matrices!sparse|)}

\subsection{Stacks}
\label{sec:ref-ami-stack}

\index{stacks|(}

External stacks are implemented through the templated class
\verb|AMI_stack<T>|, which is a subclass of \verb|AMI_STREAM<T>|.  In
addition to the normal operations operations on streams, an
\verb|AMI_stack<T>| has member functions \verb|AMI_err push(const &T
t)| and \verb|AMI_err pop(T **ppt)|.  The former appends a copy of the
item \verb|t| to the end of the stream, increasing it's length by one.
The latter removes the last item from the stream, decreasing it's
length by one and storing a pointer to the removed object in the space
pointed to by \verb|ppt|.  An example of the use of an external stack
can be seen in the convex hull code in Section~\ref{sec:convex-hull}.

\index{stacks|)}

\subsection{Elementwise and Scalar Elementwise Arithmetic}
\label{sec:ref-ami-arith}

\index{elementwise arithmetic|(} 

Elementwise arithmetic on streams is done through the use of scan
management objects designed specifically for this purpose.  They are
used as parameters to \verb|AMI_scan()|, just like any other scan
management object.  To operate on two input streams and produce a
single output stream, each of whose elements is computed from the
corresponding elements of the input streams, we use a scan management
object of class \verb|AMI_scan_op<T>|, where \verb|op| is one of
\verb|add|, \verb|sub|, \verb|mult|, or \verb|div|.  As long as
\verb|T| is a type that has the necessary operator (i.e. \verb|+|,
\verb|-|, \verb|*|, or \verb|/|) then the corresponding class
\verb|AMI_scan_op<T>| can be instantiated.

If the two input streams are not of the same length, then elementwise
operations will only continue as long as there is data available from
the shorter of the two streams.  Thus, the output stream will be
exactly as long as the shorter of the two input streams.  No attempt
is made to use an identity if one stream runs out before the other.

A related class of scan management object,
\verb|AMI_scan_scalar_op<T>| produces an output object equal to
\verb|t op s| for each input object \verb|t| and some scalar |s|.
The value of \verb|s| is set at the time the object is constructed,
not at initialization time (i.e. when \verb|initialize()| is called.
For example, the declaration
\begin{verbatim}
    AMI_scan_scalar_div<double> ssd(17.0);
\end{verbatim}
declares a scan management object that will produce a stream of output
each element of which is one seventeenth the corresponding input.

Since dense matrices with elements of type \verb|T| are a subclass of
\verb|AMI_STREAM<T>|, elementwise arithmetic operations on dense
matrices are implemented on top of scans using elementwise arithmetic
operations.

\index{elementwise arithmetic|)}


\chapter{The Implementation of TPIE}

This chapter discusses the implementation of TPIE.  It is primarily
targeted at those who might wish to port TPIE to additional platforms
or implement similar systems.  

\section{The Structure of TPIE}
\index{structure!of TPIE}
\index{components!of TPIE}

TPIE has three main components, the The Access Method Interface
(AMI)\index{access method interface}, the Block Transfer Engine
(BTE)\index{block transfer engine}, and the Memory Manager
(MM)\index{memory manager}.  The BTE handles block transfer for a
single processor.  The MM performs low level memory management across
all the processors in the system.  The AMI works on top of the MM and
one or more BTEs, each running on a single processor, to provide a
uniform interface for application programs.  Applications that use
this interface are portable across hardware platforms, since they
never have to deal with the underlying details of how I/O is performed
on a particular machine.

The BTE is intended to bridge the gap between the I/O hardware and the
rest of our system.  It works alongside the traditional buffer
cache\index{buffer cache} in a UNIX system.  Unlike the buffer
cache\index{buffer cache}, which must support concurrent access to
files from multiple address spaces, the BTE is specifically designed
to support high throughput processing of data from secondary memory
through a single user level address space.  In order to efficiently
support the merging, distribution, and scanning paradigms, the BTE
provides stream oriented buffer replacement policies.  To further
improve performance, some implementations of the BTE move data from
disk directly into user space rather than using a kernel level buffer
cache\index{buffer cache}.  This saves both main memory space and
copying time.  Although the BTE runs on a single processor, it can
support concurrent access to multiple disks\index{parallel disks},
allocating and managing buffer space for all of them concurrently.

The MM\index{memory manager} manages random access memory on behalf of
TPIE.  It is the most architecture-dependent component of the system.
On a single processor or multiprocessor system with a single global
address space, the MM is relatively simple; its task is to allocate
and manage the physical memory used by the BTE.  On a distributed
memory system, the MM has the additional task of coordinating
communication between processors and memory modules in order to
support the primitives that the AMI provides.

The AMI\index{access method interface} is a layer between the BTE and
user level processes.  It implements fundamental access methods, such
as scanning, permutation routing, merging, distribution, and batch
filtering. It also provides a consistent, object-oriented interface to
application programs.  The details of how these access methods are
implemented depends on the hardware on which the system is running.
For example, recursive distribution will be done somewhat differently
on a parallel disk machine than on a single disk machine.  The AMI
abstracts this fact away, allowing an application program that calls a
function such as
\verb|AMI_partition_and_merge()|\index{AMI_partition_and_merge@{\tt 
AMI\_partition\_and\_merge}} to work correctly
regardless of the underlying I/O system.

The key to keeping the AMI simple and flexible is the fact that its
user accessible functions serve more as templates for computation than
as actual problem solving functions.  The details of how a computation
proceeds within the template is up to the application programmer, who
is responsible for providing the functions that the template applies
to data.

\section{The Access Method Interface (AMI)}
\index{access method interface|(}
\index{AMI|see{access method interface}}
\label{sec:ref-ami}

Talk about AMI streams and the member functions an implementation must
support. 
\index{access method interface|)}

\section{AMI Entry Points}
\label{sec:ref-entry}

\subsection{Scanning}
\label{sec:ref-imp-ami-scan}

\index{scanning|(}
\index{scanning|)}

\subsection{Merging}
\label{sec:ref-imp-ami-merge}

\index{merging|(}
\index{merging|)}

\subsection{Comparison Sorting}
\label{sec:ref-imp-ami-sort}

\index{sorting!comparison|(}
\index{sorting!comparison|)}

\subsection{Key Bucket Sorting}
\label{sec:ref-imp-ami-kb-sort}

\index{sorting!key bucket|(}
\index{sorting!key bucket|)}

\subsection{General Permuting}
\label{sec:ref-imp-ami-gp}

\index{permutation!general|(}
\index{permutation!general|)}

\subsection{Bit Permuting}
\label{sec:ref-imp-ami-bp}

\index{permutation!bit|(}
\index{permutation!bit|)}

\subsection{Dense Matrices}
\label{sec:ref-imp-ami-matrix}

\index{matrices!dense|(}
\index{matrices!dense|)}

\subsection{Sparse Matrices}
\label{sec:ref-imp-ami-sm}

\index{matrices!sparse|(}
\index{matrices!sparse|)}

\subsection{Stacks}
\label{sec:ref-imp-ami-stack}

\index{stacks|(}
\index{stacks|)}

\subsection{Elementwise Arithmetic}
\label{sec:ref-imp-ami-arith}

\index{elementwise arithmetic|(}
\index{elementwise arithmetic|)}

\section{The Block Transfer Engine (BTE)}
\label{sec:ref-bte}
\index{block transfer engine|(}
\index{BTE|see{block transfer engine}}

The BTE is lowest layer of TPIE.  It is the layer that is ultimately
responsible for moving blocks of data from physical disk devices to
main memory and back.  We hope that in most cases it will be possible
for the BTE to work with device drivers provided by the machine
vendor's operating system.  In some cases, however, new drivers will
undoubtedly have to be written.  The BTE is also responsible for
maintaining the integrity of streams striped across multiple disks
attached to a single CPU, which it will do as described
in\cite{vitter:parmem1}.  The BTE is not, however, responsible for
coordinating the actions of multiple CPU's and the disks attached to
them.  A separate instance of the BTE will run on each such CPU, and
their actions will be coordinated by a single multi-threaded MM
running at a higher level.  The reason for the functional split
between the two levels is that it will likely be advantageous to be
able to use a single BTE written for a specific piece of hardware with
more than one MM, for example, one MM written for a homogeneous
environment and one for a heterogeneous environment.

Implementations of BTE streams are written as subclasses of the class
\verb|BTE_stream|, which is defined as follows:

BTE stream implementations must support the following member
functions:

\index{block transfer engine|)}

\section{The Memory Manager (MM)}
\label{sec:ref-mm}
\index{memory manager|(}
\index{MM|see{memory manager}}

The MM is the layer of TPIE that sits between the AMI interface and the
BTE.  Its primary role is managing main memory, including memory that
may be distributed across multiple physical machines.  The performance
of many of the AMI stream operations, such as sorting, permuting,
merging, and distribution depend critically on the efficient use of
main memory.  The first thing the MM will have to do to achieve this
is bypass the virtual memory system provided by UNIX and related
operating systems.  The second thing it has to do is bypass the
traditional UNIX buffer cache and take charge of managing the blocks
of data provided by the BTE.  In some cases, operating system kernels
will have to be modified in order for the MM to do its job.  In modern
micro-kernel operating systems, however, the MM may be able to operate
entirely as a user level process.

In multiple CPU environments, the job of the MM will be complicated by
the need to manage multiple banks of memory.  In tightly coupled
homogeneous parallel environments, this task is likely to be made far
simpler by existing hardware and operating system support.  In
distributed, and in particular in heterogeneous environments, the MM
will have to work with various network protocols and drivers to
accomplish its task.

Some comments on the current simple MM that we have and some OS issues
that come up in attempting to make it more robust.
\index{memory manager|)}

\section{TPIE Logging}
\label{sec:logging}


\chapter{TPIE Performance Tuning}

\section{Virtual and Non-virtual Streams}


\section{Inlining Operation Management Object Member Functions}


\section{Using Multiple Physical Devices}


\chapter{Test and Sample Applications}


\section{General Structure and Operation}

The test and sample applications distributed with TPIE are in the
verb|test| directory.  The test programs are designed primarily to
test the operation of the system to verify that it has been installed
correctly and is as bug free as possible.  These applications all have
names of the form \verb|test_*|.  The sample applications are designed
to demonstrate the use of TPIE in the solution of non-trivial
problems.

The test and sample applications all share a small amount of common
initialization and argument parsing code.  They all include the header
file \verb|app_config.h|, which selects a particular implementation of
streams at the AMI and BTE levels.  They
also all use the same argument parsing function \verb|parse_args()|,
which parses certain default arguments and then uses a callback
function for arguments specific to one particular application.

Much of the functionality provided by the common initialization and
argument passing code is intended to eventually be subsumed by
operating system provided services.  For example, the amount of main
memory a particular application is permitted to use can be set via a
command line argument.  It is up to the user to be sure that this
number is reasonable and does not exceed the true amount of main
memory available to the application.  In the future, it is hoped that
this information will be provided by the operating system.

\verb|parse_args()| is declared as follows:

\begin{verbatim}
    parse_args();
\end{verbatim}


The following is a summary of the common command line arguments that
are parsed by \verb|parse_args()|.
\begin{description}
\item[\verb|-t testsize|]
Set the size of the test to be run to \verb|testsize|.  Typically this
is the number of objects to be put into the application produced input
stream.  In matrix tests, however, it is the number of rows and
columns is the test matrices.  If this argument is not passed, then
the default value of 8 Meg is used.
\item[\verb|-m memsize|]
The number of bytes of main memory that the application is permitted to
use.  The MM\index{memory manager} will ensure that no more than this amount is
used.  If this option is not specified, then a default value of 2 Mb
is used.
\item[\verb|-z randomseed|]
Seed the random number generator with the value \verb|randomseed|.
This is useful for debugging or testing, when we want several runs of
the application to rely on the same series of pseudo-random numbers.
For applications that do not generate test data randomly, this has no
effect. 
\item[\verb|-v|]
Toggle verbose mode.  When running in verbose mode, report major
actions of the running program to verb|stdout|.
\end{description}

Each application specific argument appears in the string pointed to by
\verb|aso| as a single character, possibly followed by the single
character `\verb|:|', indicating that the argument requires a value.
For example, if \verb|aso| pointed to the string ``\verb|ax:z|'' then the
following command line arguments would all be parsed correctly:
\begin{description}
\item[\verb|-a|]
\item[\verb|-x 123|]
\item[\verb|-a -x 123|]
\item[\verb|-ax123|]
\item[\verb|-x123 -a|]
\end{description}
In each case, \verb|parse_app()| would be called to take some
application specific action for each of the arguments.  It would be
called once with \verb|opt| set to `\verb|a|' and \verb|optarg| set to
\verb|NULL|, and/or once with \verb|opt| set to `\verb|x|' and
\verb|optarg| pointing to the string ``\verb|123|.''  When multiple arguments
are present on the command line, they are parsed from left to right.

The following is an example of how a test application, in this case
\verb|test_ami_sort|, can use application specific command line
arguments to set up it's global state.

\begin{verbatim}
static const char as_opts[] = "R:S:rsao";
void parse_app_opt(char c, char *optarg)
{
    switch (c) {
        case 'R':
            rand_results_filename = optarg;
        case 'r':
            report_results_random = true;
            break;
        case 'S':
            sorted_results_filename = optarg;
        case 's':
            report_results_sorted = true;
            break;
        case 'a':
            sort_again = !sort_again;
            break;
        case 'o':
            use_operator = !use_operator;
            break;
    }
}

int main(int argc, char **argv)
{
    parse_args(argc,argv,as_opts,parse_app_opt);

    ...

    return 0;
}
\end{verbatim}

\section{Test Programs}

The test programs include with TPIE are as follows:

\begin{description}
\item[\verb|test\_ami\_merge|] Test fixed way merging with direct
  calls to \verb|AMI_merge()|, as described in 
  Section~\ref{sec:ref-ami-merge}.
\item[\verb|test\_ami\_pmerge|] Test many-way merging using 
  \verb|AMI_partition_and_merge()|, as described in 
  Section~\ref{sec:ref-ami-merge}.
\item[\verb|test\_ami\_sort|] Test sorting using \verb|AMI_sort()| as
  described in Section~\ref{sec:ref-ami-sort}.
\item[\verb|test\_ami\_gp|] Test general permutation using
  \verb|AMI_general_permute()| as described in Section~\ref{sec:ref-ami-gp}.
\item[\verb|test\_ami\_bp|] Test bit permutations using
  \verb|AMI_bit_permute()| as described in
  Section~\ref{sec:ref-ami-bp}.
\item[\verb|test\_matrix|]
\item[\verb|test\_bit\_matrix|] Test main memory matrix manipulation
  and arithmetic.  This is used both by the bit permuting code
  described in Section~\ref{sec:ref-ami-bp} and the dense matrix
  multiplication code described in Section~\ref{sec:ref-ami-matrix}
  for internal manipulation of sub-matrices of external memory
  matrices.
\item[\verb|test\_ami\_matrix\_pad|] Test padding of external
  matrices.  This is the preprocessing step for the external dense
  matrix multiplication algorithm TPIE uses, which is described in 
  Section~\ref{sec:ref-ami-matrix}. 
\item[\verb|test\_ami\_matrix|] Test external dense matrix arithmetic
  as described in Section~\ref{sec:ref-ami-matrix}.
\item[\verb|test\_ami\_sm|] Test external sparse matrix arithmetic
  as described in Section~\ref{sec:ref-ami-sm}.
\item[\verb|test\_ami\_stack|] Test external memory stacks as
  described in Section~\ref{sec:ref-ami-stack}.
\item[\verb|test\_ami\_arith|] Test element-wise arithmetic on
  external memory streams as described in Section~\ref{sec:ref-ami-arith}.
\end{description}

\section{Sample Applications}

The sample applications included with TPIE are as follows:

\begin{description}
\item[\verb|ch2|] Two dimensional convex hull\index{convex hull}
  program using Graham's scan.  It is implemented using a scan
  management object that maintains the upper and lower hull internally
  as external memory stacks.  Much of the code in this application
  appears in Section~\ref{sec:convex-hull}.
\item[\verb|lr|] An implementation of an asymptotically optimal list
  ranking \index{list ranking} algorithm.  The idea of geometrically
  decreasing computation is used.  Much of the code in this
  application appears in Section~\ref{sec:list-ranking}.
\item[\verb|nas\_ep|] An I/O-efficient implementation of the NAS EP
  parallel benchmark.  This benchmark generates pairs of independent
  Gaussian random variates.
\item[\verb|nas\_is|] An I/O-efficient implementation of the NAS IS
  parallel benchmark.  This benchmark sorts integers using one of a
  variety of approaches.
\end{description}

Detailed descriptions of the NAS parallel benchmarks are available
from the \htmladdnormallink{NAS Parallel Benchmark Home Page}%
{http://www.nas.nasa.gov/NAS/NPB/}
\begin{latexonly}
at URL \verb|http://www.nas.nasa.gov/NAS/NPB/|.
\end{latexonly}

\chapter*{Acknowledgements}
\addcontentsline{toc}{chapter}{Acknowledgements}

The development of TPIE was supported in part by the National Science
Foundation under grant CCR-9007851 and by the U.S. Army Research
Office under grant DAAL03-91-G-0035.

I would like to thank the following people for helpful discussions
concerning algorithms and implementation techniques which influenced
the development of TPIE: 
\htmladdnormallink{Jeff Vitter}{%
\begin{rawhtml}
  http://www.cs.duke.edu/~jsv/HomePage.html
\end{rawhtml}%
}, 
\index{Vitter, Jeff}
\htmladdnormallink{Eddie Grove}{%
\begin{rawhtml}
  http://www.cs.duke.edu/cgi-bin/facinfo?efg
\end{rawhtml}%
}, 
\index{Grove, Eddie}
\htmladdnormallink{Roberto Tamassia}{%
\begin{rawhtml}
  http://www.cs.brown.edu/people/rt/
\end{rawhtml}%
}, 
\index{Tamassia, Roberto}
\htmladdnormallink{Yi-Jen Chiang}{%
\begin{rawhtml}
  http://www.cs.brown.edu/people/yjc/
\end{rawhtml}%
}, 
\index{Chiang, Yi-Jen}
\htmladdnormallink{Mike Goodrich}{%
\begin{rawhtml}
  http://www.cs.jhu.edu/goodrich/home.html
\end{rawhtml}%
}, 
Jyh-Jong Tsay, 
\index{Tsay, Jyh-Jong}
\htmladdnormallink{Lars Arge}{%
\begin{rawhtml}
  http://www.daimi.aau.dk/~large/
\end{rawhtml}%
},
\index{Arge, Lars}
\htmladdnormallink{Tom Cormen}{%
\begin{rawhtml}
  http://www.cs.dartmouth.edu/faculty/cormen.html
\end{rawhtml}%
}, 
\index{Cormen, Tom}
Len Wisniewski, 
\index{Wisniewski, Len}
Liddy Shriver,
\index{Shriver, Liddy}
and 
\htmladdnormallink{David Kotz}{%
\begin{rawhtml}
  http://www.cs.dartmouth.edu/faculty/kotz.html
\end{rawhtml}%
}.
\index{Kotz, David}

I would also like to thank the following people and institutions for
providing access to the hardware on which TPIE design and development
are ongoing: 
\htmladdnormallink{Brown University Department of Computer
  Science}{http://www.cs.brown.edu}, 
\index{Brown University!Department of Computer Science}
for Sun Sparc 10s running
Solaris; 
\htmladdnormallink{Duke University Department of Computer
  Science}{http://www.cs.duke.edu}, 
\index{Duke University!Department of Computer Science}
for a variety of Sun workstations
running SunOS and for DEC Alphas running OSF/1; 
Yale Patt\index{Patt, Yale} and the ACAL Lab in the 
\htmladdnormallink{Department of Electrical Engineering and
  Computer Science}{http://www.eecs.umich.edu} at the University of
Michigan, 
\index{University of Michigan!ACAL Lab}
for a DEC Alpha running OSF/1 and for an HP 9000 running
HP-UX; 
\htmladdnormallink{David
  Kotz}{http://www.cs.dartmouth.edu/faculty/kotz.html} and the
\htmladdnormallink{Dartmouth College Department of Computer
  Science}{http://www.cs.dartmouth.edu},
\index{Kotz, David}\index{Dartmouth College!Department of Computer Science}
 for MIPS based DECstations
running Ultrix.  

Finally, I would like to thank 
\htmladdnormallink{Owen Astrachan}{http://www.cs.duke.edu/\~ola/HomePage.html}
\index{Astrachan, Owen}
for his helpful discussions on some of the finer points of the C++
language.


\bibliography{tpie-refs}

\part{Appendices}

\appendix

\chapter{The GNU General Public License, Version 2}
\label{app:gpl}
\index{GNU software!General Public License}
\index{GNU General Public License}
\index{license}

\centerline{June, 1991}

\vspace{1 ex}

Copyright \copyright 1989, 1991 Free Software Foundation, Inc.,
675 Mass Ave, Cambridge, MA 02139, USA

\begin{center}
  Everyone is permitted to copy and distribute verbatim copies of this
  license document, but changing it is not allowed.
\end{center}

\section*{Preamble}

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

\section*{GNU GENERAL PUBLIC LICENSE
  TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION}

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The ``Program'', below,
refers to any such program or work, and a ``work based on the Program''
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term ``modification''.)  Each licensee is addressed as ``you''.

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

\begin{description}
\item[a)] You must cause the modified files to carry prominent notices
  stating that you changed the files and the date of any change.
\item[b)] You must cause any work that you distribute or publish, that
  in whole or in part contains or is derived from the Program or any
  part thereof, to be licensed as a whole at no charge to all third
  parties under the terms of this License.
\item[c)] If the modified program normally reads commands
  interactively when run, you must cause it, when started running for
  such interactive use in the most ordinary way, to print or display
  an announcement including an appropriate copyright notice and a
  notice that there is no warranty (or else, saying that you provide a
  warranty) and that users may redistribute the program under these
  conditions, and telling the user how to view a copy of this License.
  (Exception: if the Program itself is interactive but does not
  normally print such an announcement, your work based on the Program
  is not required to print an announcement.)
\end{description}

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

\begin{description}
\item[a)] Accompany it with the complete corresponding
  machine-readable source code, which must be distributed under the
  terms of Sections 1 and 2 above on a medium customarily used for
  software interchange; or,
\item[b)] Accompany it with a written offer, valid for at least three
  years, to give any third party, for a charge no more than your cost
  of physically performing source distribution, a complete
  machine-readable copy of the corresponding source code, to be
  distributed under the terms of Sections 1 and 2 above on a medium
  customarily used for software interchange; or,
\item[c)] Accompany it with the information you received as to the
  offer to distribute corresponding source code.  (This alternative is
  allowed only for noncommercial distribution and only if you received
  the program in object code or executable form with such an offer, in
  accord with Subsection b above.)
\end{description}

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and ``any
later version'', you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

\vspace{2 ex}

\centerline{\bf NO WARRANTY}

\vspace{2 ex}

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM ``AS IS'' WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

\section*{END OF TERMS AND CONDITIONS}

\section*{How to Apply These Terms to Your New Programs}

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the ``copyright'' line and a pointer to where the full notice is found.

\begin{verbatim}
    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) 19yy  <name of author>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
\end{verbatim}

Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

\begin{verbatim}
    Gnomovision version 69, Copyright (C) 19yy name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.
\end{verbatim}

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a ``copyright disclaimer'' for the program, if
necessary.  Here is a sample; alter the names:

\begin{quote}
  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  $<$signature of Ty Coon$>$, 1 April 1989
  Ty Coon, President of Vice
\end{quote}

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Library General
Public License instead of this License.

\addcontentsline{toc}{part}{Index}

\printindex

\end{document}


