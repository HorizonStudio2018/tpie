%%
%% $Id: ami_reference.tex,v 1.11 2000-11-08 17:24:30 hutchins Exp $
%%
\chapter{TPIE Programmer's Reference}
\plabel{cha:reference}

\comment{LA: Statistics somewhere!}

\comment{LA: pqueue, internal sort, ect somewhere?}

\noindent
TPIE has three main components:  
\begin{enumerate}
    \item The Access Method Interface (AMI) contains the
    main user-callable functions and macros (e.g.
    \myverb{AMI\_merge()}, \myverb{AMI\_sort()}, etc.)

    \item The Block Transfer Engines (BTEs) provide
    interfaces to the I/O system (efficient transfer of disk
    blocks) which are used internally by the AMI services
    
    \item The TPIE Memory Manager \myverb{MM\_manager} manages
    internal memory and enforces limits set by the
    application programmer.
\end{enumerate}

The AMI functions on top of the Memory Manager and one or
more BTEs to provide a uniform interface for application
programs. Applications that use this interface are portable
across hardware platforms, since they can ignore the details
of how I/O is performed on a particular machine. This
chapter contains a description of the AMI and Memory Manager
entry points that an application programmer might normally
use. An application programmer may select an appropriate BTE
for the hardware platform and operating system at hand, but
will typically will not request services from a BTE
directly. Refer to Chapter~\ref{cha:implementation} for a
description of BTEs and for other TPIE implementation
details.


\section{TPIE Memory Management}
\plabel{sec:mm-ref}
\index{memory manager|(}

The Memory Manager components of TPIE provide services related to
the management of internal memory:
\begin{itemize}
\item allocation and deallocation of (internal)
memory as requested by the \myverb{new} and \myverb{delete} operators,
\item accounting of memory usage (when required),
\item enforcing of the user-specified internal memory usage
limit (when required),
\item logging of memory allocation requests (when required).
\end{itemize}

%The TPIE memory manager \myverb{MM\_manager}, is built from the source
%files \myverb{mm_register.cpp}, \myverb{mm_base.cpp}, \myverb{mm_register.h}, and
%\myverb{mm\_base.h}. 
The TPIE memory manager \myverb{MM\_manager} traps memory
allocation and deallocation requests in order to monitor
and enforce memory usage limits. It provides a number of
user-callable functions and services.

\begin{itemize}
\item Replacement of the default C++ \myverb{new} operator
\begin{verbatim}
void * operator new (size_t) sz;
\end{verbatim}
This function returns a pointer to a memory block of size
\myverb{sz} bytes, where \myverb{sz} is initialized by the
compiler, and contains the size of the object
for which memory is required. The calling program syntax is
exactly the same as when invoking the default \myverb{new}
operator of the C++ library, i.e. 

\begin{verbatim}
anObject *p;
p = new anObject; 
\end{verbatim}

\item Replacement of the default C++ \myverb{delete} and
\myverb{delete []} operators
\begin{verbatim}
void operator delete    (void *ptr);
void operator delete [] (void *ptr);
\end{verbatim}

These functions deallocate the memory pointed to by
\myverb{ptr}. The calling program syntax and usage is exactly
the same as when invoking the default \myverb{delete} and
\myverb{delete []} operators of the C++ runtime library.

\end{itemize}

Although provisions exist for alternative memory managers,
TPIE currently provides only one. TPIE's memory manager is the object
\myverb{MM\_manager}, which has global scope. 

The following public methods of object \myverb{MM\_manager} are
provided:

\begin{itemize}
\item Setting an application's memory limit:
\begin{verbatim}
MM_err set_memory_limit (size_t size);
\end{verbatim}

The memory limit is set to \myverb{size} bytes. If the
specified mamory limit is greater than or equal to the
amount of memory already allocated, \myverb{set\_memory\_limit}
returns \myverb{MM\_ERROR\_NO\_ERROR}, otherwise
\myverb{MM\_ERROR\_EXCESSIVE\_ALLOCATION}. By default, successive
calls to operator \myverb{new} will cause the program to abort
if the resulting memory usage would exceed \myverb{size}
bytes. This behaviour can be controlled explicitly by the
use of methods \myverb{enforce\_memory\_limit},
\myverb{warn\_memory\_limit} and \myverb{ignore\_memory\_limit}.
See below for details.

\item Setting memory limit enforcement behaviour:
\begin{verbatim}
MM_err enforce_memory_limit();
MM_err ignore_memory_limit ();
MM_err warn_memory_limit   ();
\end{verbatim}

Methods \myverb{enforce\_memory\_limit},
\myverb{ignore\_memory\_limit} and
\myverb{warn\_memory\_limit} are used to specify the
behaviour desired in the event that the user-specified
memory limit is exceeded. These methods cause TPIE to abort,
continue without generating a warning, or continue after
generating a warning, respectively.

\item Query memory parameters

\begin{verbatim}
size_t  memory_available();
size_t  memory_used();
size_t  memory_limit();
\end{verbatim}

Method \myverb{memory\_available()} returns the number of bytes
of memory which can be allocated before the user-specified
limit is reached, \myverb{memory\_used} returns the number of
bytes of memory currently allocated, and \myverb{memory\_limit}
returns the memory limit as set by the last call to method
\myverb{set\_memory\_limit}.

Application programs which wish to limit their main memory
usage can check via \myverb{memory\_available} whether a
contemplated memory allocation request would exceed their
self-imposed threshold.

\item Query space overhead

\begin{verbatim}
int space_overhead();
\end{verbatim}

TPIE imposes a small space overhead on each memory
allocation request received by operator \myverb{new}. This involves
increasing each allocation request by a fixed number of
bytes. The precise size of this increase is machine
dependent, but typically 8 bytes. Method \myverb{space\_overhead}
returns the size of this increase.
\end{itemize}

\subsection{Using the Memory Manager: An Example}

The following (toy) program creates new elements of a linked
list until its specified memory limit has been reached.

\begin{verbatim}
// This program illustrates the use of the main public 
// entry points in the TPIE memory manager object "MM_manager".
// It creates nodes in a linked list and stops when a predefined memory 
// limit would be exceeded if it continued.

#include "app_config.h"
#include <ami.h>
#define  MY_MEMORY_LIMIT 4*1024*1024;

int    overhead, nodeCount;
size_t mem_limit = MY_MEMORY_LIMIT;
class  myNode 
      { public:
           int i[1020/4];
           myNode *next;
      };
myNode *firstNode, *currentNode, *previousNode;

void 
main (int argc, char *argv[]){

  overhead = MM_manager.space_overhead();
  nodeCount = 0;
  MM_manager.set_memory_limit(mem_limit);
  currentNode = firstNode = 0;

  while ((sizeof(myNode)+overhead)<= MM_manager.memory_available()) { 
     currentNode = new myNode;
     if (firstNode == 0) 
        firstNode = currentNode;
     else
       (*previousNode).next = currentNode;
     (*currentNode).next = 0;
     previousNode = currentNode;
     nodeCount++;
  };
  cout << nodeCount << " list nodes of size " << (int) sizeof(myNode); 
  cout << " were allocated within my memory limit of ";
  cout << (size_t) mem_limit << " bytes \n";
};
\end{verbatim}

Under PC Solaris, this program gives the following output:
\begin{verbatim}
4064 list nodes of size 1024 were allocated within my memory limit of 4194304 bytes
\end{verbatim}
\index{memory manager|)}


\section{AMI Streams}\index{streams!AMI|(}
\plabel{sec:ref-ami-stream}

\comment{%
   LA: This whole section needs an overhaul! (e.g. check
   that everything is included and correct).} 
An AMI stream is an ordered collection of objects of a
common type, stored in secondary memory.  In some
applications, the elements of a stream might be integers.
In others, they might be objects of an arbitrarily complex,
user-defined class.  For example, a stream of objects of class
\myverb{foo} called \myverb{foo\_stream} might be created in a
TPIE program as follows:

\index{AMI_STREAM@{\tt AMI\_STREAM}}
\begin{verbatim}
AMI_STREAM<foo> foo_stream;
\end{verbatim}

\myv{AMI\_STREAM} functions as if it were a class in C++. It
is actually a compile-time macro. See
Section~\ref{cha:implementation} for more details. For most
applications, \myv{AMI\_STREAM} will resolve to the class
\myv{AMI\_stream\_single}, which is the TPIE base class for
a stream backed by a single file (normally on a single
disk).

\comment{LA: Probably put some general discussion of stream types
(read/write/append) and persistence here. Same comment about substreams and
{\em current\_item}. DH: changes made.}

\subsection{AMI Stream Types}
\index{AMI_STREAM@{\tt AMI\_STREAM}!stream types|(}

The stream type of an \myverb{AMI\_STREAM} indicates what
operations are permitted on the stream.\comment{LA:
   Check that this works ok in the code - also check that
   r\_only is correct. Another problem is that AMI and BTE
   WRITE\_STREAM flags have different semantics - needs to
   be cleaned up}
The stream type can be specified via the\myverb{AMI\_STREAM}
constructor (see below).  


An \myverb{AMI\_STREAM} can have one of four different types
\begin{itemize}
    
    \item \myverb{AMI\_READ\_STREAM}: Input operations on
    the stream are permitted, but output is not permitted.
    
    \item \myverb{AMI\_WRITE\_STREAM}: Output operations are
    permitted, but input operations are not permitted. 
    
    \item \myverb{AMI\_APPEND\_STREAM}: Output is appended
    to the end of the stream. Input operations are not
    permitted. This is similar to
    \myverb{AMI\_WRITE\_STREAM} except that if the stream is
    constructed on a file containing an existing stream,
    objects written to the stream will be appended at the
    end of the stream.\comment{LA: It this true?
   DH: seems ok}

\item \myverb{AMI\_READ\_WRITE\_STREAM}: Both input and output
    operations are permitted.
\end{itemize}
\index{AMI_STREAM@{\tt AMI\_STREAM}!stream types|)}

\subsection{AMI\_STREAM Constructors}
\label{member:ami-constructor}
\index{AMI_STREAM@{\tt AMI\_STREAM}!constructors|(}

\myverb{AMI\_STREAM} constructors perform two basic
steps:
\begin{enumerate}
    \item Create an \myverb{AMI\_STREAM} object whose member
    functions provide services for manipulating a
    stream,
    \item Create a \myv{BTE\_STREAM} object customized to
    the chosen file access method, and associate it with the
    \myverb{AMI\_STREAM} object of step~1. At this time the
    constructor of the \myv{BTE\_STREAM} object opens the
    file that stores the stream contents.
\end{enumerate}

\noindent
There are four constructors available for \myv{AMI\_STREAM}:

\begin{itemize}
\item
\begin{verbatim}
     AMI_STREAM();
\end{verbatim}
A new stream of type \myverb{AMI\_READ\_WRITE\_STREAM} is
constructed on a file with a randomly generated name. (See
below for an discussion of stream types.)

\item
\begin{verbatim}
     AMI_STREAM(const char *path_name);
\end{verbatim}
A stream of type \myverb{AMI\_READ\_WRITE\_STREAM} is constructed on the file whose pathname is given.
If the file does not already exist, a new stream is
constructed on a newly created file with the specified file
name. If the file already exists, it
is checked if it contains an \myverb{AMI\_STREAM}, and if so,
the new stream is constructed on this file.

\item
\begin{verbatim}
     AMI_STREAM(const char *path_name, AMI_stream_type st);
\end{verbatim}
A stream of type \noiv{st} is constructed on the file whose
pathname is given.

\item
\begin{verbatim}
     AMI_STREAM(BTE_STREAM<T> &bs);
\end{verbatim}
A stream is constructed from an existing
\myverb{BTE\_STREAM} (see Section~\ref{sec:ref-bte}). This
constructor will not normally be used by a TPIE application
programmer\comment{LA: Why do we have it then? DH: for
   completeness}. The new \myverb{AMI\_STREAM} gets the same
type as the \myverb{BTE\_STREAM}.
\end{itemize}

\index{AMI_STREAM@{\tt AMI\_STREAM}!constructors|)}

\subsection{Persistence}
\index{AMI_STREAM@{\tt AMI\_STREAM}!persist}
\index{persistence}

When a TPIE program exits, any \myv{AMI\_STREAM} objects are
destroyed, but the underlying files can be either retained
(i.e. they can persist) or be deleted from the file system.
The TPIE programmer can select either option (prior to
invocation of the \myv{AMI\_STREAM} destructor) by way of
the \myv{AMI\_STREAM} member function \myv{persist} (see
page~\pageref{member:ami-persist}).

\subsection{Substreams}\index{substreams!of AMI streams|(}

A TPIE substream is an AMI stream that is part of another
AMI stream. More precisely, a substream $B$ of a
stream $A$ is defined as a contiguous range of objects from
the ordered collection of objects that make up the stream
$A$.  If desired, one can construct substreams of substreams
of substreams {\em ad infinitum}. Since a substream is a
stream in its own right, many of the stream member functions
can be applied to a substream. Exceptions are noted below.

A substream can be created via the pseudo-constructor\footnote{% 
   The reason we do not use a real constructor is to get
   around the fact that constructors can not be virtual.
   Please see Section~\ref{cha:implementation} for more
   details.} 
\myverb{new\_substream()}, which has the following
prototype: (recall that an AMI\_STREAM on a single disk
inherits from AMI\_stream\_single.)\comment{LA: Why is it
   called AMI\_stream\_single? Change! DH: reason
   explained}\comment{LA: Change when parallel disks are
   introduced}
\begin{verbatim}
AMI_err AMI_stream_single<T>::new_substream ( 
                            AMI_stream_type    st,
                            off_t              sub_begin,
                            off_t              sub_end,
                            AMI_base_stream<T> **sub_stream );
\end{verbatim}
where \myverb{st} specifies the type of the stream, and the
offsets \myverb{sub\_begin} and \myverb{sub\_end} of type
\myverb{off\_t} define at which object in the original
stream $A$ the new substream $B$ will begin and end. Upon
completion, \myverb{*sub\_stream} points to the newly
allocated and created substream.

% The reason why substreams use a pseudo-constructor is
% is discussed in the Implementation chapter of this manual
% (Section~\ref{cha:implementation}.


% Because \myverb{new\_substream()} is not a constructor, but rather a
% function each particular implementation of which calls an appropriate
% constructor, it can be a pure virtual function in the stream base class,
% which forces it to be defined for all actual stream
% implementations.\comment{LA: I don't understand this paragraph}

%This is discussed in more detail in
%Sections~\ref{sec:ref-bte}
%and~\ref{sec:ref-ami},\comment{LA: Is it?} which discuss the
%implementation of the AMI and BTE in more detail.
\index{substreams!of AMI streams|)}

\subsection{AMI\_STREAM Services}
\noindent
The \myverb{AMI\_STREAM} classes offer the following
standard services: 

\subsubsection{Reading and Writing Streams}

\index{read_item()@{\tt read\_item()}!AMI|(}\index{write_item()@{\tt write\_item()}!AMI|(}
\begin{verbatim}
    AMI_err read_item  ( T **elt );
    AMI_err write_item ( const T &elt );
\end{verbatim}

\myverb{AMI\_STREAM}s have a notion of \myverb{current\_item} in the stream of
objects. The \myverb{read\_item(T **elt)} function returns with \myverb{*elt}
pointing to the current object of the \myverb{AMI\_STREAM<T>} and the
\myverb{write\_item(T elt)} function returns after setting the current object
of \myverb{AMI\_STREAM<T>} to the value \myverb{elt}. The two functions also
increment the \myverb{current\_item}.
\index{read_item()@{\tt read\_item()}!AMI|)}\index{write_item()@{\tt write\_item()}!AMI|)}

Since it can be useful to read or write many objects at a time from or to
an \myverb{AMI\_STREAM}, TPIE provides two functions to do so.

\index{read_array()@{\tt read\_array()}!AMI|(}\index{write_array()@{\tt write\_array()}!AMI|(}
\begin{verbatim}
    AMI_err read_array  ( T *mm_space, off_t *len );
    AMI_err write_array ( const T *mm_space, off_t len );
\end{verbatim}

Method \myverb{read\_array} reads \myverb{*len} objects from
the \myverb{current\_item} into the array
\myverb{mm\_space}. Similarly, \myverb{write\_array} writes
an array.\comment{LA: Why is there a difference in the
   passing of len? DH: read receives a value of len and
   write specifies a value for len.} 

\subsubsection{Positioning a Stream}

\myverb{current\_item} can be explicitly changed with the \myverb{seek} function.

\index{seek()@{\tt seek()}!AMI}
\begin{verbatim}
    AMI_err seek(off_t offset);
\end{verbatim}

\subsubsection{Resizing a Stream}

A stream can be resized to a specified number of objects via
the \myverb{truncate()} member function.

\index{truncate()@{\tt truncate()}!AMI}
\begin{verbatim}
    AMI_err truncate(off_t offset);
\end{verbatim}
If \noiv{offset} is less than the number of objects in the
stream, \myverb{truncate()} truncates the stream to
\noiv{offset} objects. If \noiv{offset} is more than the
number of objects in the stream, \myverb{truncate()} extends
the stream to the specified number of objects. In either
case \myverb{current\_item} will be moved to the new end of
the stream.

\subsubsection{Calculating Main Memory Usage}

\index{main_memory_usage()@{\tt main\_memory\_usage()}!AMI}
\begin{verbatim}
    AMI_err main_memory_usage(size_t *usage,
                              MM_stream_usage usage_type);
\end{verbatim}

This function is used for obtaining the amount of main memory used by an
\noiv{AMI\_STREAM} object (in bytes). \myverb{usage\_type} is one of
\myverb{MM\_STREAM\_USAGE\_CURRENT}, \myverb{MM\_STREAM\_USAGE\_MAXIMUM}, and
\myverb{MM\_STREAM\_USAGE\_SUBSTREAM} which gives the current use, the maximum
that will ever be used, and the additional amount which will be used
by each substream created, respectively.\comment{LA: There seems to be two
more types defined in mm.base.h - what are they?}

\subsubsection{Unix File Name}

\index{name()@{\tt name()}!AMI}
\begin{verbatim}
    AMI_err name(char **stream_name);
\end{verbatim}

Returns the path to the UNIX file storing the stream.  The
name will be stored in newly allocated space.

\subsubsection{Stream Length}

\index{stream_len()@{\tt stream\_len()}!AMI}
\begin{verbatim}
    off_t stream_len(void);
\end{verbatim}

Returns the current number of objects in the stream.

\subsubsection{Available Streams}
\index{available_streams()@{\tt available\_streams()}!AMI}
\begin{verbatim}
    int available_streams(void);    
\end{verbatim}

Typically, there is an operating system limit on the number
of open files. This translates into a limit on the number of
TPIE streams. Method \myverb{available\_streams} returns the
number of streams which can still be constructed.\comment{%
   This should not be a member of an AMI\_STREAM, but
   instead should be a member of a ``resource
   manager(RM)''.}

\subsubsection{Persistence of Streams}
\label{member:ami-persist}
\index{persistence!AMI}
\begin{verbatim}
    void persist(persistence);
\end{verbatim}

Sets the persistence of the stream to one of the following:
\begin{itemize}
\item \myverb{PERSIST\_DELETE}: Delete the stream from the disk when it is
  destructed.
\item \myverb{PERSIST\_PERSISTENT}: Do not delete the stream from the disk when
  it is destructed.
%\item \myverb{PERSIST\_READ\_ONCE}: Delete each block of data from the disk as
%  it is read.
\end{itemize}

By default, all streams are deleted at destruction time
(\myverb{PERSIST\_DELETE}).\comment{LA: There seems to be an unused
PERSIST\_READ\_ONCE flag as well! (from darren's delete-block
stuff). Remove?!}
\index{streams!AMI|)}


\section{AMI Entry Points}
\plabel{sec:ref-ami}
\index{AMI entry points}\index{entry point!AMI|see{AMI entry points}}

\subsection{Scanning}
\plabel{sec:ref-ami-scan}
\index{scanning|(}
\index{AMI_scan()@{\tt AMI\_scan()}|(}

The simplest polymorph of \myverb{AMI\_scan()} is
\begin{verbatim}
    AMI_err AMI_scan(ST *smo, AMI_STREAM<T> *outstream);
\end{verbatim}
which generates an output stream of objects of type \myverb{T}.
\myverb{smo} is a pointer to a scan management object of user-defined
class \myverb{ST}.  \myverb{ST} should provide member functions {\tt
  AMI\_err initialize(void)} and {\tt AMI\_err operate(T *out1,
  AMI\_SCAN\_FLAG *sf)}.

Scanning can also read and process an input stream of objects of type
\myverb{T}.  
\begin{verbatim}
    AMI_err AMI_scan(AMI_STREAM<T> *instream, ST *smo);
\end{verbatim}
Again, \myverb{smo} is a pointer to a scan management object of used
defined class \myverb{ST}.  \myverb{ST} should provide member functions
{\tt AMI\_err initialize(void)} and {\tt AMI\_err operate(const T
  \&in1, AMI\_SCAN\_FLAG *sf)}.

\myverb{AMI\_scan()} may also read multiple input streams, each
potentially of a different type, and write multiple output streams,
each potentially of a different type.  
\index{scanning!multi-type}
\begin{verbatim}
    AMI_err AMI_scan(AMI_STREAM<T1> *instream1, 
                     AMI_STREAM<T2> *instream2, ..., 
                     ST *smo, 
                     AMI_STREAM<U1> *os1, 
                     AMI_STREAM<U1> *os2, ...);
\end{verbatim}
\index{AMI_scan()@{\tt AMI\_scan()}|)}
The scan management object class \myverb{ST} should have an operate
method taking the appropriate number and type of operands.  For
example, {\tt AMI\_err operate(const T1 \&in1, const T2 \&in2, ...,
  AMI\_SCAN\_FLAG *sfin, U1 *out1, U2 *out2, ..., AMI\_SCAN\_FLAG
  *sfout)}.  In the current implementation of TPIE there can be
between zero and four inputs and zero and four outputs.


\subsubsection{Scan Management Objects}  
\index{operation management objects!scan|(}

A scan management object class must provide two member
functions for \myverb{AMI\_scan()} to call.\comment{%
   LA: Something about subclass of AMI\_scan\_object (also
   in previous text)?} 

\begin{itemize}
    
    \item \index{initialize()@{\tt initialize()}}
\begin{verbatim}
    AMI_err initialize(void);
\end{verbatim}
    Initializes a scan management object to prepare
    it for a scan.  This member function is called once by
    each call to \myverb{AMI\_scan()} in order to initialize
    the scan management object before any data processing
    takes place.  This function should return
    \myverb{AMI\_ERROR\_NO\_ERROR} if successful, or an
    appropriate error otherwise. See
    Section~\ref{sec:ami-errors} for a list of error codes.
    
    \item \index{operate()@{\tt operate()}|(}
    
    Most of the work of a scan is typically done in the scan
    management object's \myverb{operate()} member function:
\begin{verbatim}
    AMI_err operate(const T1 &in1, ...,  AMI_SCAN_FLAG *sfin,
                    U1 *out1, ..., AMI_SCAN_FLAG *sfout);
\end{verbatim}
    
    One or more input objects or one or more output
    parameters must be specified.  These must correspond in
    number and type to the streams passed to the polymorph
    of \myverb{AMI\_scan()} with which this scan management
    object is to be used.
    
    If present, the inputs \noiv{*in1, ...} are application
    data items of type \noiv{T1}, and \myverb{sfin} points
    to an array of flags, one for each input.  On entry to
    \myverb{operate()}, flags that are set (non-zero)
    indicate that the corresponding inputs contain data.  If
    on exit from \myverb{operate()}, the input flags are
    left untouched, \myverb{AMI\_scan()} assumes that the
    corresponding inputs were processed.  If one or more
    input flags are cleared (set to zero) then
    \myverb{AMI\_scan()} assumes that the corresponding
    inputs were not processed and should be presented again
    on the next call to \myverb{operate()}.  This permits
    out of step scanning\index{scanning!out of step}, as
    illustrated in Section~\ref{sec:tut-out-of-step}.
    
    If present, the outputs \noiv{*out1, ...} are
    application data items of type \noiv{U1}, and
    \myverb{sfout} points to an array of flags, one for each
    output. On exit from \myverb{operate()}, the outputs
    should contain any objects to be written to the output
    streams, and the output flags must be set to indicate to
    \myverb{AMI\_scan()} which outputs are valid and should
    be written to the output streams.
    
    The return value of \myverb{operate()} will normally be
    one of the following:
    \begin{itemize}
        \item \myverb{AMI\_SCAN\_CONTINUE}:
        \index{AMI_SCAN_*@{\tt AMI\_SCAN\_*}} indicates that
        the function should be called again with any
        ``taken'' inputs replaced by the next objects from
        their respective streams
        \item \myverb{AMI\_SCAN\_DONE}: indicates that the
        scan is complete and no more input needs to be
        processed.
    \end{itemize}
    
    Note that \myverb{operate()} is permitted to return
    \myverb{AMI\_SCAN\_CONTINUE} even when the input flags
    indicate that there is no more input to be processed.
    This is useful if the scan management object maintains
    some internal state that must be written out after all
    input has been processed.  \comment{%
       LA: Something about special built-in scan management
       objects, e.g, ASCII input/output}

\index{operate()@{\tt operate()}|)} 
\end{itemize}

Examples of the use of scan management objects are given in
Section~\ref{sec:tut-scanning} as well as in the test applications that
appear in the TPIE distribution.

\index{operation management objects!scan|)}
\index{scanning|)}


\subsection{Merging}
\plabel{sec:ref-ami-merge}
\index{merging|(}

As discussed in Section~\ref{sec:tut-merging}, the amount of
available main memory limits the number of streams that can
be merged in a single pass. Subject to the available main
memory, TPIE entry point \myverb{AMI\_generalized\_merge()}
allows an arbitrary number of streams to be merged in one
pass. TPIE will attempt to read the first block of each
stream into the internal memory, and will update the
contents of these buffers as the merge progresses. At least
one block buffer is also required for the output stream from
the merge.  \comment{LA: Understandable? DH: rewritten.},

\index{AMI_generalized_merge()@{\tt AMI\_generalized\_merge()}}
\begin{verbatim}
AMI_err AMI_generalized_merge ( AMI_STREAM<T> **instreams, 
                    arity_t arity,
                    AMI_STREAM<T> *outstream, 
                    MergeMgr *m_obj);
\end{verbatim}

\noindent
where
\begin{itemize}
    \item \myverb{instreams} is an array of pointers to the
    input streams, all of which are streams of objects of
    type \myverb{T}.
    \item \myverb{arity} is the number of input streams.
    \item \myverb{outstream} is the output stream.
    \item \myverb{m\_obj} points to a merge management
    object which will control the merge.
\end{itemize}

Merge management objects are described below. If the number of
streams is large enough that all streams cannot be properly buffered in the
available main memory\comment{LA: Do the reader know what we are talking
about here? DH: should be ok now}, then this function will fail, returning
\myverb{AMI\_ERR\_INSUFFICIENT\_MAIN\_MEMORY}.

%Most programs are unlikely to need to call
%\myverb{AMI\_merge()} directly.\comment{LA: Really?} More
%commonly, 
Programmers may also want to partition a stream into
substreams small enough to fit in main memory, operate on
each in main memory, and then merge them together, possibly
in several passes if low memory conditions dictate. TPIE
provides the following entry point for this situation:
\index{AMI_partition_and_generalized_merge()@{\tt AMI\_partition\_and\_generalized\_merge()}}
\begin{verbatim}
AMI_err AMI_partition_and_generalized_merge(AMI_STREAM<T> *instream,
                                AMI_STREAM<T> *outstream, 
                                MergeMgr *m_obj);
\end{verbatim}
\noindent
where
\begin{itemize}
    \item \myverb{*instream} is the
    input stream, which is a stream of objects of
    type \myverb{T}.
    \item \myverb{*outstream} is the output stream.
    \item \myverb{m\_obj} points to a merge management
    object which will control the merge.
\end{itemize}
This entry point takes care of all the details of determining how much
main memory is available, how big the initial substreams can be, how
many streams can be merged at a time, and how many levels of merging
must take place. 
%It is used internally by the old TPIE merge
%sorting entry points (see Section~\ref{sec:ref-mrg-sorting}

\subsubsection{Merge Management Objects}
\index{operation management objects!merge|(} 

\index{operate()@{\tt operate()}|(}
\index{initialize()@{\tt initialize()}|(}

A merge management object must provide \myverb{initialize()}
and \myverb{operate()} member functions, whose purposes are
analogous to their namesakes for scan management objects.

\begin{itemize}
    
    \item \index{initialize()@{\tt initialize()}}
    The user's \myverb{initialize()} member function is
    called by TPIE at the beginning of the merge so that
    application-specific data structures (if any) can be
    initialized.
\begin{verbatim}
    AMI_err initialize(arity_t arity, const T * const *in,
                       AMI_merge_flag *taken_flags,
                       int &taken_index);
\end{verbatim}
 
    where
    \begin{itemize}
        \item \myverb{arity} is the number of input streams
        in the merge,
        \item \myverb{in} is a pointer to an array of
        pointers to input objects, each of which is the
        first objects appearing in one of the input streams,    
        \item \myverb{taken\_flags} an array of flags
        indicating which of the inputs are present (i.e.
        which of the input streams is not empty), and a
        pointer to an output object.
    \end{itemize}
    
    The typical behavior of \myverb{initialize()} is to
    place all the input objects into a data structure and
    then return \myverb{AMI\_MERGE\_READ\_MULTIPLE} to
    indicate that it used (and is now finished with) all of
    the inputs which were indicated to be valid by
    \myverb{taken\_flags}.  \myverb{initialize} need not
    process all inputs; it can turn off any flags in
    \myverb{taken\_flags} corresponding to inputs that
    should be presented to \myverb{operate()}.
    Alternatively, it can set \myverb{taken\_index} to the
    index of a single input it processed and return
    \myverb{AMI\_MERGE\_CONTINUE}.
%\index{AMI_MERGE_*@{\tt AMI\_MERGE\_*}}.
    \item \index{operate()@{\tt operate()}}
    When performing a merge, TPIE relies on the application
    programmer to provide code to determine the order of any
    two application data elements, and certain other
    application-specific processing. By convention, TPIE
    expects these decisions to be made by the
    \myverb{operate} function:
\begin{verbatim}
    AMI_err operate(const T * const *in, AMI_merge_flag *taken_flags,
                    int &taken_index, T *out);
\end{verbatim}
    The \myverb{operate()} member function is called
    repeatedly to process input objects.  Typically,
    \myverb{operate()} will choose a single input object to
    process, and set \myverb{taken\_index} to the index of
    the pointer to that object in the input array.  This
    object is then typically added to a dynamic data
    structure maintained by the merge management object.  If
    output is generated, for example by removing an object
    from the dynamic data structure, \myverb{operate()}
    should return \myverb{AMI\_MERGE\_OUTPUT}, otherwise, it
    returns either \myverb{AMI\_MERGE\_CONTINUE} to indicate
    that more input should be presented, or
    \myverb{AMI\_MERGE\_DONE} to indicate that the merge has
    completed.
    
    Alternatively, \myverb{operate()} can clear the elements
    of \myverb{taken\_flags} that correspond to inputs it
    does not currently wish to process, and then return
    \myverb{AMI\_MERGE\_READ\_MULTIPLE}.  This is generally
    undesirable because, if only one input is taken, it is
    far slower than using \myverb{taken\_index} to indicate
    which input was taken.  The merge management object must
    clear all other flags, and then TPIE must test all the
    flags to see which inputs were or were not processed.
\end{itemize}

\index{operate()@{\tt operate()}|)}
\index{initialize()@{\tt initialize()}|)}

The \myverb{AMI\_partition\_and\_generalized\_merge()} entry point 
requires a merge management object to provide three
additional member functions:

\begin{itemize}
    \item \index{main_mem_operate()@{\tt main\_mem\_operate()}}
\begin{verbatim}
    AMI_err main_mem_operate(T* mm_stream, size_t len);
\end{verbatim}
\noindent
where
    \begin{itemize}
        \item \myverb{mm\_stream} is a pointer to an array
        of objects that have been read into main memory,
        \item \myverb{len} is the number of objects in the
        array.
    \end{itemize}
    
    This function is called by
    \myverb{AMI\_partition\_and\_merge()} when a substream of
    the data is small enough to fit into main memory, and
    the (application-specific) processing of this subset of
    the data can therefore be completed in internal memory.

    
    \item \index{space_usage_per_stream()@{\tt space\_usage\_per\_stream()}}
\begin{verbatim}
    size_t space_usage_per_stream(void);
\end{verbatim}
    This function should return the amount of main memory
    that the merge management object will need per per input
    stream. Merge management objects are allowed to maintain
    data structures whose size is linear in the number of
    input streams being processed.

    \item \index{space_usage_overhead()@{\tt space\_usage\_overhead()}}
\begin{verbatim}
    size_t space_usage_overhead(void);
\end{verbatim}
    This function should return an upper bound on the number
    of bytes of main memory\comment{LA: In bytes? DH: yes.}
    the merge management object will allocate in addition to
    the portion that is linear in the number of streams.
    
\end{itemize}

%There are examples of merge management objects in
%Section~\ref{sec:merging} as well as in the test applications that
%appear in the TPIE distribution.

\index{operation management objects!merge|)}
\index{merging|)}


\subsubsection{AMI merging without Merge Management Objects}
\plabel{sec:ref-miami-merge}
%\index{merging!without a merge management object|(}

\comment{LA: merging without merge management object in index}

\index{AMI_merge()@{\tt AMI\_merge()}|(} By using
appropriate \myverb{operate()} and
\myverb{main\_mem\_operate()} functions,
\myverb{AMI\_generalized\_merge()} and
\myverb{AMI\_partition\_and\_generalized\_merge()} can be
used to conveniently program operations which require
generalized merging (such as database and spatial JOIN
operations, for example).  TPIE also provides several merge
entry points for the special case of merging sorted streams
to produce a single, interleaved output stream.  These entry
points allow this common application to be processed faster
than would be possible using the generalized merge entry
points.

\begin{itemize}
    \item
\begin{verbatim}
  AMI_err AMI_merge ( AMI_STREAM<T> **instreams,
                      arity_t arity, 
                      AMI_STREAM<T> *outstream);
\end{verbatim}
This polymorph works on streams of objects for which the operator
\myverb{<} is defined.

\item 
\begin{verbatim}
  AMI_err AMI_merge ( AMI_STREAM<T> **instreams,
                      arity_t arity,
                      AMI_STREAM<T> * outstream,
                      int (*cmp)(CONST T&, CONST T&));
\end{verbatim}
This polymorph uses an explicit user defined function to compare
objects. The function takes two objects of type T and returns a negative,
zero or positive number depending on whether or not the first object is
less than, equal to or greater than the second object in the desired
merging order.

\item
\begin{verbatim}
  AMI_err AMI_merge ( AMI_STREAM<T> **instreams,
                      arity_t arity,
                      AMI_STREAM<T> * outstream,
                      MergeMgr *mmo);
\end{verbatim}
This polymorph expects the merge management object
\myverb{*mmo} to have a member function \myverb{compare}.
\begin{verbatim}
int compare ( CONST T &r1, CONST T & r2); 
\end{verbatim}
The function takes two objects of type T and returns a negative,
zero or positive number depending on whether or not the first object is
less than, equal to or greater than the second object in the desired
merging order.

\item
\begin{verbatim}
  AMI_err AMI_merge ( AMI_STREAM<T> **instreams,
                      arity_t arity,
                      AMI_STREAM<T> *outstream,
                      KEY dummy,
                      MergeMgr *mmo);
\end{verbatim}
The third polymorph assumes that the objects (of type T) in the streams
being merged have a field (of type \myverb{KEY}) with well-defined (possibly
by means of overloading) \myverb{<} operator, and that the ordering of the
object is to be based on the total order of this field. \myverb{keyoffset} is
the offset within an object of type T of this key field, and \myverb{dummy} is
a (any) variable of type \myverb{KEY}.\comment{LA: Something about this being
for C++ reasons?}

\comment{LA: We need to add comparator class polymorph DH: Done}
\end{itemize}

All of the \myverb{AMI\_merge()}  polymorphs return
\myverb{AMI\_ERR\_INSUFFICIENT\_MAIN\_MEMORY} if not enough
main memory is available to perform the merge.
\index{AMI_merge()@{\tt AMI\_merge()}|)}

%The motivation for such a function is to exploit situations
%in which the KEY field is often much smaller than the T type object: For
%instance, if T is a rectangle, each object may be of size approximately 40
%bytes, whereas if one is interested in sorting along the X co-ordinate, the
%KEY may be of size 4 or 8 bytes.  If such information is known to the
%programmer, the above entry point can exploit it by using
%appropriately-suited simple internal memory merging techniques: Often, the
%small size of the KEY field can improve the running time of the operation.

%We also provide three entry points analogous to the
%\myverb{AMI_partition_and_merge()} function that do not require merge
%management objects and that use the \myverb{MIAMI_single_merge_*()} routines
%the way \myverb{AMI_partition_and_merge()} uses the
%\myverb{AMI_single_merge()}: Each analogue entry point corresponds to one of
%the above three \myverb{MIAMI_single_merge_*()} entry points.
%
%
%The first function, based on \myverb{MIAMI_single_merge_stream()},
\begin{verbatim}
template<class T>
AMI_err AMI_partition_and_merge (AMI_STREAM<T> *instream,
                                 AMI_STREAM<T> *outstream)
\end{verbatim}
provides the same functionality as the
\myverb{AMI\_partition\_and\_generalized\_merge()} function except that it requires 
the type T to have well defined  \myverb{ < } and \myverb{ > } operators.

%The second function, based on  \myverb{MIAMI_single_merge_cmp()},
\begin{verbatim}
template<class T>               
AMI_err AMI_partition_and_merge (AMI_STREAM<T> *instream,
                                 AMI_STREAM<T> *outstream,
                                 int (*cmp)(CONST T&, CONST T&)
                                  )
\end{verbatim}
has the same requirements as the \myverb{AMI\_merge\_cmp()} function.
%
%The third function,   based on  \myverb{MIAMI_single_merge_Key()},
\begin{verbatim}
template<class T, class KEY>
AMI_err AMI_partition_and_merge_Key(AMI_STREAM<T> *instream,
                                   AMI_STREAM<T> *outstream, 
                                              int keyoffset, 
                                               KEY dummykey)
\end{verbatim}
provides similar functionality as \myverb{AMI\_partition\_and\_merge()}
except that it is  uses KEY and {\tt keyoffset}
information while merging and sorting, as indicated above.
%


%%% THIS IS SOMETHING THAT SHOULD MAYBE GO IN LATER IN THE IMPLEMENTATION
%%% SECTION (and the distribution)

%The function
%\begin{verbatim}
%template<class T, class KEY>
%AMI_err AMI_replacement_selection_and_merge_Key(AMI_STREAM<T> *instream,
%                                               AMI_STREAM<T> *outstream, 
%                                               int keyoffset,
%                                               KEY dummykey)
%\end{verbatim}
%is the same as \myverb{AMI_partition_and_merge_Key()} above, except that
%it uses a fundamentally different run formation algorithm. The 
%\myverb{AMI_replacement_selection_and_merge_Key()} function uses
%the replacement selection (Algorithm R in Knuth's Vol 3, Section 5.4.1)
%technique to form runs. This technique is known to produce runs that
%are twice as long and half as many as the ordinary run formation
%technique used in  \myverb{AMI_partition_and_merge_Key()} on average,
%and so has the potential of reducing the number of merge passes.
%But the internal memory performance of replacement selection may
%be a little worse than the internal memory performance of the ordinary
%run formation technique; so what is eventually better could very well
%depend on various parameters.


\subsection{Distribution}
\plabel{sec:ref-ami-dist}
\index{distribution}

\tobewritten


\subsection{Comparison Sorting}
\plabel{sec:ref-ami-sort}
\index{sorting!comparison|(}

\subsection{Merge Sorting} \plabel{ref:mrg-sorting}
\index{sorting!merge|(} 

TPIE offers several entry points for sorting which use
merging as their underlying paradigm. Please see
Section~\ref{sec:tut-mrg-sorting} for more details of this
approach.

Currently, TPIE offers three merge sorting variants. The
user must decide which variant is most appropriate for their
circumstances.  All accomplish the same goal, but the
performance can vary depending on the situation. They differ
mainly in the way they perform the merge phase of merge
sort, specifically how they maintain their heap data
structure used in the merge phase. The three variants are as
follows:
\begin{itemize}
    \item \myverb{AMI\_sort}: keeps the (entire) first record
    of each sorted run (each is a stream) in a heap. This
    approach is most suitable when the record consists
    entirely of the record key.
    
    \item \myverb{AMI\_ptr\_sort}: keeps a pointer to the
    first record of each stream in the heap. This approach
    works best when records are very long and the key
    field(s) take up a large percentage of the record.

    \item \myverb{AMI\_key\_sort}: keeps the key field(s) and
    a pointer to the first record of each stream in the
    heap. This approach works best when the key field(s) are
    small in comparison to the record size.
\end{itemize}

Any of these variants will accomplish the task of sorting an
input stream in an I/O efficient way, but there can be
noticeable differences in processing time between the
variants. As an example, \myverb{AMI\_key\_sort} appears to be
more cache-efficient than the others in many cases, and
therefore often uses less processor time, despite extra data
movement relative to \myverb{AMI\_ptr\_sort}.

In addition to the three variants discussed above, there are
multiple choices within each variant regarding how the
actual comparison operations are to be performed. These
choices are described in detail for \myverb{AMI\_sort}, below.

\subsubsection{AMI\_sort()}
\myverb{AMI\_sort()} has three polymorphs, described below.
We will refer to these as the (1) comparison operator, (2)
comparison function, and (3) comparison class versions of
\myverb{AMI\_sort}. The comparison operator version tends to
be the fastest and most straightforward to use. The
comparison class version is comparable in speed (maybe
slightly slower), but somewhat more flexible, as it can support
multiple, different sorts on the same keys. The comparison
function version is slightly easier to use than the
comparison object version, but typically it is measureably slower.
Please refer to Section~\ref{sec:tut-mrg-sorting} for examples
of the use of these versions of \myverb{AMI\_sort()}.

\noindent{\bf Comparison operator version:}  This version works on streams of
objects for which the operator \myverb{<} is defined.  It
has the following prototype:

\begin{verbatim}
    AMI_err AMI_sort ( AMI_STREAM<T> *instream, 
                       AMI_STREAM<T> *outstream );
\end{verbatim}


\noindent{\bf Comparison function version:}
This version uses an explicit function to determine the
relative order of two objects in the input stream.  This is
useful in cases where we may want to sort a stream of
objects in several different ways.  It has the following
prototype:

\begin{verbatim}
    AMI_err AMI_sort ( AMI_STREAM<T> *instream, 
                       AMI_STREAM<T> *outstream, 
                       int (*cmp)(KEY *key1, KEY *key2) );
\end{verbatim}


\noindent{\bf Comparison class version:} 
This version of \myverb{AMI\_sort()} is similar to the
comparison function version, except that the comparison
function is now a method of a user-defined comparison
object. This object must have a public member function named
\myverb{compare}, whose calling sequence and functionality
is the same as for a comparison function (as described
above). It has the following prototype:

\begin{verbatim}
    AMI_err AMI_sort ( AMI_STREAM<T> *instream, 
                       AMI_STREAM<T> *outstream, 
                       SortMgr *smo );
\end{verbatim}

\subsubsection{AMI\_ptr\_sort()}

The \myverb{AMI\_ptr\_sort} variant of merge sort in TPIE
keeps only a pointer to each record in the heap used to
perform merging of runs. Similar to \myverb{AMI\_sort}
above, it offers comparison operator, comparison function,
and comparison class polymorphs. The syntax is identical to
that illustrated in the \myverb{AMI\_sort} examples; simply
replace \myverb{AMI\_sort} by \myverb{AMI\_ptr\_sort}. The
three prototypes are as follows:

\begin{verbatim}
    AMI_err AMI_ptr_sort ( AMI_STREAM<T> *instream, 
                           AMI_STREAM<T> *outstream );

    AMI_err AMI_ptr_sort ( AMI_STREAM<T> *instream, 
                           AMI_STREAM<T> *outstream, 
                           int (*cmp)(KEY *key1, KEY *key2) );

    AMI_err AMI_ptr_sort ( AMI_STREAM<T> *instream, 
                           AMI_STREAM<T> *outstream, 
                           SortMgr *smo );
\end{verbatim}


\subsubsection{AMI\_key\_sort()}

The \myverb{AMI\_key\_sort} variant of TPIE merge sort keeps
the key field(s) plus a pointer to the corresponding record
in an internal heap during the merging phase of merge sort.
It requires a sort management object with member functions
\myverb{compare} and \myverb{copy}. The prototype of
\myverb{AMI\_key\_sort} is as follows:

\begin{verbatim}
    AMI_err AMI_key_sort ( AMI_STREAM<T> *instream, 
                           AMI_STREAM<T> *outstream, 
                           KEY dummyKey, 
                           KeySortMgr *smo );
\end{verbatim}

The \noiv{dummyKey} argument of \myverb{AMI\_key\_sort()} is a a
dummy argument having the same type as the user key, and
\noiv{*smo} is the sort management
object, having user-defined \myverb{compare} and
\myverb{copy} member functions as described below.

The \myverb{compare} member function has the following
prototype:
\begin{verbatim}
   inline int compare (const KEY & k1, const KEY & k2);
\end{verbatim}

The user-written \myverb{compare} function computes the
order of the two user-defined keys \noiv{&k1} and
\noiv{&k2}, and returns $-1$, $0$, or $+1$ to indicate that
$&k1<&k2$, $&k1==&k2$, or $&k1>&k2$ respectively.
It will be called by the internals of \noiv{AMI_key_sort} to
determine the relative order of records during the sort.

The \myverb{copy} member function has the following
prototype:
\begin{verbatim}
   inline void copy (KEY *key, const T &record);
\end{verbatim}

The user-written \myverb{copy} function constructs the
user-defined key \noiv{*key} from the contents of the
user-defined record \noiv{&record}. It will be called by the
internals of \noiv{AMI_key_sort} to make copies of record
keys as necessary during the sort.

\index{sorting!merge|)} 

% \noindent{\bf The old writeup of the sort functions:}

% TPIE provides a sort function \myverb{AMI\_sort()} based on merge
% sort. Version \version~of TPIE also contains alpha versions of a new
% sorting function \myverb{AMI\_optimized\_sort()} which is also based on merge
% sort. It is planned that after thorough testing this function will be the
% default TPIE \myverb{AMI\_sort()} function. Section~\ref{sec:ref-imp-ami-sort}
% contains a discussion of the difference between the two functions. In the
% future a number of other sort algorithms will be implemented and it is the
% intention that when calling \myverb{AMI\_sort()} TPIE should automatically
% select the best sorting algorithm for the given hardware platform.

% \subsubsection{AMI\_sort}

% In order to provide maximum flexibility to programmers, \myverb{AMI\_sort()}
% has three polymorphs.
% \index{AMI_sort()@{\tt AMI\_sort()}|(}
% \begin{verbatim}
%   AMI_err AMI_sort(AMI_STREAM<T> *instream, AMI_STREAM<T> *outstream)
%   AMI_err AMI_sort(AMI_STREAM<T> *instream, AMI_STREAM<T> *outstream,
%                    int (*cmp)(CONST T&, CONST T&));
%   AMI_err AMI_sort(AMI_STREAM<T> *instream, AMI_STREAM<T> *outstream,
%                    comparator<T> *cmp)
% \end{verbatim}

% All three polymorphs take an argument \myverb{instream}, which is a pointer
% to the input stream, and \myverb{outstream}, which is a pointer to the output
% stream to which the sorted results are to be written. The first polymorph
% takes no additional arguments and the \myverb{<} operator is used in order to
% determine the relative order of two input objects. Thus, the type \myverb{T}
% of objects in the stream must have a member \myverb{operator<}.

% The second polymorph relies on a user supplied comparison function, similar
% to that used in the familiar C library function \myverb{qsort()} and in one
% of the polymorphs of \myverb{AMI\_merge()}. It is often useful to use a
% comparison function when the type of the objects being sorted has several
% fields, and one sometimes wish to sort on one field and sometimes on
% another.  Two different comparison functions can be defined, eliminating
% the need to provide a \myverb{<} operator that is compile-time bound to
% perform comparisons in a particular way.

% The final polymorph of \myverb{AMI\_sort()} relies on a comparator
% class.\comment{LA: Function object change.}
% Instead of defining a comparison function, the programmer defines a
% comparator class, which has a member function
% \begin{verbatim}
%     int compare(const T& t1, const T& t2);
% \end{verbatim}
% which behaves exactly as the comparison function described above.
% \index{AMI_sort()@{\tt AMI\_sort()}|)}
% Examples of comparison based sorting appear in
% Section~\ref{sec:tut-cmp-sorting} as well as in the test applications that
% appear in the TPIE distribution.  Section~\ref{sec:list-ranking}
% illustrates the use of multiple comparison functions to sort streams of
% objects in different ways.

% \subsubsection{AMI\_optimized\_sort}

% \index{AMI_optimized_sort()@{\tt AMI\_optimized\_sort()}|(}
% \myverb{AMI\_optimized\_sort()} also have three polymorphs.\comment{LA: We need
% to add a comparator class polymorph. That will also make it possible to
% clean up the code in ami\_optmized\_merge.h}

% \begin{verbatim}
%   AMI_err AMI_optimized_sort(AMI_STREAM<T> *instream, AMI_STREAM<T>
%                              *outstream) 
%   AMI_err AMI_optimized_sort(AMI_STREAM<T> *instream,
%                              AMI_STREAM<T> *outstream, int (*cmp)(CONST T&,
%                              CONST T&)); 
%   AMI_err AMI_optimized_sort(AMI_STREAM<T> *instream,
%                              AMI_STREAM<T> *outstream, 
%                              int keyoffset, KEY dummy);
% \end{verbatim}

% As for \myverb{AMI\_sort()} the first two polymorphs rely on \myverb{<} and user
% supplied comparison functions, respectively. Similar to one of the
% \myverb{AMI\_merge()} polymorphs, the third polymorphs assumes that the
% objects in the input stream have a field with well-defined \myverb{<}
% operator, and that the ordering of the object is to be based on the total
% order of this field. \myverb{keyoffset} is the offset within an object of
% type T of this key field and \myverb{dummy} is a (any) variable of type
% \myverb{KEY}.\comment{LA: Something about this being for C++ reasons?}
% \index{AMI_optimized_sort()@{\tt AMI\_optimized\_sort()}|)}
\index{sorting!comparison|)}

\subsection{Key Bucket Sorting}
\plabel{sec:ref-ami-kb-sort}

\index{sorting!key bucket|(}

\tobeextended

\begin{verbatim}
AMI_err AMI_kb_dist()
\end{verbatim}

\begin{verbatim}
AMI_err AMI_kb_sort()
\end{verbatim}

\begin{verbatim}
AMI_err AMI_kb_dist_key()
\end{verbatim}

\begin{verbatim}
AMI_err AMI_kb_sort_key()
\end{verbatim}
\index{sorting!key bucket|)}


\subsection{General Permuting}
\plabel{sec:ref-ami-gp}

\index{permutation!general|(}

\tobeextended

\begin{verbatim}
AMI_err AMI_general_permute(AMI_STREAM<T> *instream, 
                            AMI_STREAM<T> *outstream, 
                            AMI_gen_perm_object *gpo);
\end{verbatim}
\index{permutation!general|)}

\subsection{Bit Permuting}
\plabel{sec:ref-ami-bp}

\index{permutation!bit|(}

\tobeextended

\begin{verbatim}
AMI_err AMI_BMMC_permute(AMI_STREAM<T> *instream, 
                         AMI_STREAM<T> *outstream, 
                         AMI_bit_perm_object *bpo);
\end{verbatim}
\index{permutation!bit|)}

\subsection{Dense Matrices}
\plabel{sec:ref-ami-matrix}

\index{matrices!dense|(}
\index{matrices!dense|)}

\tobewritten


\subsection{Sparse Matrices}
\plabel{sec:ref-ami-sm}

\index{matrices!sparse|(}
\index{matrices!sparse|)}

\tobewritten

\subsection{Elementwise and Scalar Elementwise Arithmetic}
\plabel{sec:ref-ami-arith}

\index{elementwise arithmetic|(} 

Elementwise arithmetic on streams is done through the use of scan
management objects designed specifically for this purpose.  They are
used as parameters to \myverb{AMI\_scan()}, just like any other scan
management object.  To operate on two input streams and produce a
single output stream, each of whose elements is computed from the
corresponding elements of the input streams, we use a scan management
object of class \myverb{AMI\_scan\_op<T>}, where \myverb{op} is one of
\myverb{add}, \myverb{sub}, \myverb{mult}, or \myverb{div}.  As long as
\myverb{T} is a type that has the necessary operator (i.e. \myverb{+},
\myverb{-}, \myverb{*}, or \myverb{/}) then the corresponding class
\myverb{AMI\_scan\_op<T>} can be instantiated.

If the two input streams are not of the same length, then elementwise
operations will only continue as long as there is data available from
the shorter of the two streams.  Thus, the output stream will be
exactly as long as the shorter of the two input streams.  No attempt
is made to use an identity if one stream runs out before the other.

A related class of scan management object,
\myverb{AMI\_scan\_scalar\_op<T>} produces an output object equal to
\myverb{t op s} for each input object \myverb{t} and some scalar \myverb{s}.
The value of \myverb{s} is set at the time the object is constructed,
not at initialization time (i.e. when \myverb{initialize()} is called.
For example, the declaration
\begin{verbatim}
    AMI_scan_scalar_div<double> ssd(17.0);
\end{verbatim}
declares a scan management object that will produce a stream of output
each element of which is one seventeenth the corresponding input.

Since dense matrices with elements of type \myverb{T} are a subclass of
\myverb{AMI\_STREAM<T>}, elementwise arithmetic operations on dense
matrices are implemented on top of scans using elementwise arithmetic
operations.

\index{elementwise arithmetic|)}


\subsection{Stacks}
\plabel{sec:ref-ami-stack}

\index{stacks|(}

External stacks are implemented through the templated class
\myverb{AMI\_stack<T>}\index{AMI_stack@{\tt AMI\_stack}}, 
which is a subclass of \myverb{AMI\_STREAM<T>}. In
addition to the normal operations operations on streams, an
\myverb{AMI\_stack<T>} has the following member functions:
\begin{itemize}
    \item \myverb{AMI\_err push(const \&T t);} This function
    appends a copy of the object \myverb{t} to the end of
    the stream, increasing its length by one.

    \item \myverb{AMI\_err pop(T **ppt);} This function
    removes the last object from the stream, decreasing its
    length by one and returning the address of a pointer to
    the popped object in \myverb{ppt}.
\end{itemize}
\index{stacks|)}

\subsection{Distribution Sweeping}
\plabel{sec:ref-ami-distsweep}
\index{distribution sweeping}

\tobewritten

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
